/* original parser id follows */
/* yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93" */
/* (use YYMAJOR/YYMINOR for ifdefs dependent on parser version) */

#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYPATCH 20140715

#define YYEMPTY        (-1)
#define yyclearin      (yychar = YYEMPTY)
#define yyerrok        (yyerrflag = 0)
#define YYRECOVERING() (yyerrflag != 0)
#define YYENOMEM       (-2)
#define YYEOF          0
#define YYPREFIX "yy"

#define YYPURE 0

#line 2 "nectar_syntax"

/*Author: Tasos Temperekidis*/

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#define MHNYMA 0

/* ----------------------------------------------------------- */
/* --------- Declarations for Syntax-Semantic Analysis ------- */
/* ----------------------------------------------------------- */


#include "nectar_defs.h"

HASH_TAB ht; /*Symbol Table for Methods,Classes and declarations*/
HASH_TAB arr_st[MAX_SYM_TABLES]; /*Method's Symbol Table*/

int topOfSt = 0; /*The current activated method's symbol table*/
int TopOfStack=-1;
int TopOfWhile=-1;
int TopOfRt = -1;
int numOfParams = 0;  /* For number of method's parameters*/
int numOfArguments =0; /* For "arguments and parameters matching"*/
int enableReturn = 1;


/*** FOR MIX CODE GENERATION ***/
int NUM_BYTES_VAR=0; /*Number of variables (for mix variable names)*/
int NUM_METH=0; /*Number of methods (for mix method names)*/
int NUM_PAR=0;
char NUM_VAR_ARR[7];
char TEMP_NUM_VAR_ARR[7];

char METHOD_NAME[50];
char METHOD_NAME_PARS[50];
char METHOD_NAME_TEMP[25];

char CLASS_NAME[50];

symbol *vs[30];
symbol *whiles[30];  /*For "break in while" checking*/
symbol *returns[30]; /* Check if return keyword exists for all cases in a method*/

symbol *p,*p1,*p2,*p3,*p4,*p5,*p6,*p7,*p8,*p9;

AstNode *TreeRoot;


#line 56 "nectar_syntax"
#ifdef YYSTYPE
#undef  YYSTYPE_IS_DECLARED
#define YYSTYPE_IS_DECLARED 1
#endif
#ifndef YYSTYPE_IS_DECLARED
#define YYSTYPE_IS_DECLARED 1
typedef union
{
    int   yint;
    char  ystr[81];
    struct AstNode_tag *stnode;
} YYSTYPE;
#endif /* !YYSTYPE_IS_DECLARED */
#line 87 "y.tab.c"

/* compatibility with bison */
#ifdef YYPARSE_PARAM
/* compatibility with FreeBSD */
# ifdef YYPARSE_PARAM_TYPE
#  define YYPARSE_DECL() yyparse(YYPARSE_PARAM_TYPE YYPARSE_PARAM)
# else
#  define YYPARSE_DECL() yyparse(void *YYPARSE_PARAM)
# endif
#else
# define YYPARSE_DECL() yyparse(void)
#endif

/* Parameters sent to lex. */
#ifdef YYLEX_PARAM
# define YYLEX_DECL() yylex(void *YYLEX_PARAM)
# define YYLEX yylex(YYLEX_PARAM)
#else
# define YYLEX_DECL() yylex(void)
# define YYLEX yylex()
#endif

/* Parameters sent to yyerror. */
#ifndef YYERROR_DECL
#define YYERROR_DECL() yyerror(const char *s)
#endif
#ifndef YYERROR_CALL
#define YYERROR_CALL(msg) yyerror(msg)
#endif

extern int YYPARSE_DECL();

#define FALSE 257
#define TRUE 258
#define INT 259
#define RETURN 260
#define IF 261
#define ELSE 262
#define WHILE 263
#define BREAK 264
#define PRINT 265
#define READ 266
#define PRINTLN 267
#define TIMES 268
#define USE 269
#define UNLESS 270
#define NOT 271
#define AND 272
#define OR 273
#define REAL 274
#define PUTS 275
#define BOOL 276
#define FUNC 277
#define RIGHTARROW 278
#define CLASS 279
#define PRIVATE 280
#define PUBLIC 281
#define ABSTRACT 282
#define METH 283
#define VAR 284
#define DEC_CONST 285
#define LITERAL 286
#define REAL_DEC_CONST 287
#define GE 288
#define LE 289
#define NE 290
#define EQ 291
#define ID 292
#define INC 293
#define DEC 294
#define ADDASSIGN 295
#define SUBASSIGN 296
#define LOWER_THAN_ELSE 297
#define YYERRCODE 256
typedef short YYINT;
static const YYINT yylhs[] = {                           -1,
    0,    1,    1,    1,    1,    2,    2,    9,   45,    3,
    8,    8,    8,    5,    5,    6,    6,    7,    7,    7,
    4,   46,   47,   10,   48,   49,   11,   12,   12,   14,
   14,   15,   15,   15,   15,   13,   16,   16,   17,   17,
   50,   18,   51,   18,   52,   18,   53,   19,   54,   19,
   19,   20,   20,   23,   23,   23,   23,   23,   23,   23,
   23,   23,   23,   23,   55,   21,   21,   21,   21,   21,
   21,   56,   21,   21,   21,   57,   21,   58,   21,   21,
   21,   21,   21,   21,   21,   21,   21,   21,   24,   24,
   24,   24,   22,   29,   30,   31,   31,   35,   36,   36,
   33,   32,   25,   25,   26,   26,   27,   27,   28,   28,
   34,   34,   34,   34,   34,   34,   37,   37,   38,   38,
   39,   39,   40,   40,   40,   41,   41,   41,   41,   41,
   41,   41,   41,   41,   41,   42,   42,   42,   42,   43,
   43,   44,   44,
};
static const YYINT yylen[] = {                            2,
    1,    2,    2,    2,    0,    2,    0,    1,    0,    5,
    0,    1,    1,    2,    0,    5,    7,    3,    5,    0,
    4,    0,    0,   10,    0,    0,   10,    3,    0,    4,
    0,    1,    1,    1,    1,    4,    2,    0,    2,    0,
    0,    6,    0,    9,    0,    8,    0,    4,    0,    6,
    0,    2,    0,    1,    1,    1,    1,    2,    2,    2,
    2,    4,    1,    2,    0,    1,    1,    1,    1,    2,
    6,    0,    9,    3,    3,    0,    6,    0,    4,    1,
    1,    2,    2,    2,    2,    2,    4,    1,    3,    3,
    1,    1,    3,    3,    3,    3,    3,    5,    5,    3,
    1,    1,    3,    1,    3,    1,    2,    1,    3,    1,
    1,    1,    1,    1,    1,    1,    3,    1,    1,    1,
    3,    1,    1,    1,    1,    1,    3,    1,    1,    1,
    1,    1,    4,    2,    2,    2,    2,    2,    2,    2,
    0,    3,    0,
};
static const YYINT yydefred[] = {                         0,
    0,   12,   13,    0,    0,    1,    0,    0,    0,    0,
   25,    0,    2,    0,    3,    4,    0,    0,    9,    0,
   32,   33,   34,   35,    0,    0,    0,    0,    0,    0,
    0,    0,   10,    0,    0,  132,  131,    0,  129,  130,
    0,    0,    0,    0,    0,    0,    0,  106,  108,    0,
    0,    0,    0,  122,  126,    0,    0,   42,    0,    0,
    0,    0,    0,  107,    0,  134,  135,  102,  137,  139,
    0,    0,    0,  136,  138,    0,  119,  120,  111,  112,
  113,  114,  115,  116,    0,    0,  123,  124,  125,    0,
   43,    0,    0,    0,    0,    0,    8,   14,   26,   30,
  127,    0,   46,  105,    0,    0,    0,    0,  121,    0,
    0,    0,    0,   21,   22,    6,    0,  133,    0,   44,
    0,   48,    0,    0,    0,   27,  142,    0,    0,    0,
   16,    0,   53,    0,   50,    0,    0,    0,    0,    0,
   17,    0,   18,    0,    0,   65,   76,   80,    0,    0,
    0,    0,   53,   36,   52,   81,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   78,
    0,    0,    0,    0,   19,   23,    0,    0,    0,    0,
    0,   93,    0,    0,    0,    0,   97,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   90,   89,   79,    0,
    0,    0,   24,    0,    0,    0,    0,    0,    0,   77,
    0,   72,    0,    0,   73,
};
static const YYINT yydgoto[] = {                          5,
    6,   94,    7,   33,   60,   61,  131,    8,   96,   97,
    9,   27,  126,   28,   25,  133,  134,   10,   58,  139,
  155,  156,  157,  175,  158,   47,   48,   49,  159,  160,
  161,   50,   51,   85,  163,  200,   52,   86,   53,   90,
   54,   55,  105,  106,   26,  124,  203,   17,  117,   31,
  110,   72,  112,  128,  167,  224,  168,  195,
};
static const YYINT yysindex[] = {                      -211,
 -270,    0,    0, -267,    0,    0, -211, -248, -211, -211,
    0,  -24,    0, -232,    0,    0,   24, -239,    0,    0,
    0,    0,    0,    0,  -51,  -54,   40, -239, 1679, -190,
   52,   33,    0, -180, -193,    0,    0,  261,    0,    0,
 1679, -205,    0, -192, -192, -172, -170,    0,    0, -237,
   64,  105,  -14,    0,    0,   12, -186,    0, -184, -207,
   33, -239,   66,    0,  -35,    0,    0,    0,    0,    0,
 1679,   52, 1679,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  261,  261,    0,    0,    0,  261,
    0,   51,   55,  -11, -177, -207,    0,    0,    0,    0,
    0, -170,    0,    0,   75, 1679,   41,  -14,    0,   52,
 1679,   52, -239,    0,    0,    0,   -6,    0,  -41,    0,
 -172,    0,  -29,   78,    0,    0,    0,   52, 1679, -173,
    0,    0,    0, -164,    0,  -32,  -25,   80, 2017,    0,
    0, 1679,    0, -155, 1679,    0,    0,    0,  215, -161,
  258,  548,    0,    0,    0,    0, -240, -244,    0,    0,
    0,   96,    0,  -32, -239, -172,   82,   87,    0, -172,
   84,    0, -172,   91,    0,  -31, 2058, 1679, 1679,    0,
 1679, -192, 1679, 1679,    0,    0, 1679, 1679, -192,  548,
  548,    0, -172, -172, 2145, -172,    0,  -57,   11,   92,
 -172, -172,   -6,  -34,  -33,    0,    0,    0,    0, 1679,
 -192, 1679,    0, 2145, 2145, -172,   93, -172, -131,    0,
 1679,    0, -172, 2145,    0,
};
static const YYINT yyrindex[] = {                         2,
    0,    0,    0,    0,    0,    0,    2,    0,    2,    2,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  167,
    0,    0,    0,    0,  495,    0,    0,    0,    0,    0,
  650, -108,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    1,    0,    0,  533,  152,    0,    0,  964,
    0,  344,   47,    0,    0,    0,    0,    0,    0, -116,
 -108,    0,   97,    0,    0,    0,    0,    0,    0,    0,
    0,  650,    0,    0,    0,  814,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  600,    0,    0,    0, -116,    0,    0,    0,    0,
    0,  407,    0,    0,    0,    0,  449,   89,    0,  650,
    0,  650,    0,    0,    0,    0,    0,    0,   98,    0,
  705,    0,  -48,    0, 1766,    0,    0,  650,    0,    0,
    0,  167,    0,    0,    0,  -48,  -48,    0,    0, 1817,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  -40,  799, 1009,
 1064,  858, 1115,  -48,    0, 1868,    0,    0, 1166, 1217,
    0, 1264, 1315, 1366, 1417, 1468,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, 1911, 1962,    0, 1515,    0,  913,    0,    0,
 1566, 1617,    0,    0,    0, 1668,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   66,    0, 1719, 2107,    0,
    0,    0,   99,    0,    0,
};
static const YYINT yygindex[] = {                         0,
   69,   45,    0,    0,   81,    0, -110,  -46,    0,    0,
    0,   13,  -59,    0,  -10,    0,    0,   20,  -61,   -7,
 -156,    0,    0,  -97, 2307,   76,   83,  120,    0,    0,
  -22, 2020,    0,    0,    0,  -50,   77,    0,   74,    0,
   73,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,
};
#define YYTABLESIZE 2528
static const YYINT yytable[] = {                         88,
  102,    5,  127,  181,   88,  101,  214,  215,    7,   29,
  103,  130,  191,   95,  130,   20,   15,   35,  130,   21,
  178,   11,   89,  180,   12,  141,  143,   87,   71,  179,
   14,  129,   88,   18,   22,  142,   23,  102,  209,   30,
  101,  102,  102,  102,  102,  102,  118,  102,  120,   95,
  122,   99,   24,  185,  211,   74,   75,  219,  220,   19,
  102,  102,  102,   20,  102,    1,  135,  225,   32,    2,
    3,  210,    4,    2,    3,   13,   20,   15,   16,   66,
   34,   67,   88,   77,   88,   78,  118,  118,  117,  118,
  118,  118,  207,  208,   56,   57,   59,   62,   63,   68,
   71,   73,  123,   76,   91,   92,  118,   93,  118,  100,
  118,  111,  113,  114,  115,  118,  125,  132,  137,    4,
  144,  187,  165,  102,  171,  102,  188,  189,  117,  117,
  222,  117,  117,  117,  190,  212,  221,   28,  140,  182,
  116,   98,   99,  213,  138,  177,  102,   77,  117,   78,
  117,  104,  117,  140,  186,  104,  181,   64,  197,  108,
  217,  107,  109,    0,   82,    0,   80,    0,    0,  118,
    0,  118,   15,   15,    0,   11,    0,    0,    0,    0,
    0,    0,    0,   15,    0,    0,    0,    0,    0,    0,
    0,  104,  104,    0,    0,  104,  104,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   29,    0,    0,
    0,  117,    0,  117,    0,  104,   88,   88,    0,   88,
   63,   88,   88,   88,   88,   88,   88,    0,    0,   63,
   88,   71,   20,   20,   88,   74,   75,   71,   71,   71,
   71,   71,    0,   20,   88,    0,   88,    0,    0,    0,
    0,   88,   88,   88,   41,    0,    0,  102,  102,   42,
  102,  102,  102,  102,  102,  102,  102,  102,  102,    0,
  102,  102,  102,  102,  104,  102,  104,  102,    0,  102,
   11,  102,  102,    0,  102,  102,    0,  102,  102,  102,
  102,  102,  102,  102,  102,  102,  102,   41,    0,    0,
   41,    0,   42,  118,  118,   42,  118,  118,  118,  118,
  118,  118,  118,  118,  118,    0,  118,  118,  118,  118,
    0,  118,    0,  118,    0,  118,    0,  118,  118,    0,
  118,  118,    0,  118,  118,  118,  118,  118,  118,  118,
  118,    0,    0,  110,    0,  117,  117,    0,  117,  117,
  117,  117,  117,  117,  117,  117,  117,    0,  117,  117,
  117,  117,    0,  117,    0,  117,    0,  117,    0,  117,
  117,    0,  117,  117,    0,  117,  117,  117,  117,  117,
  117,  117,  117,  110,  110,    0,    0,  110,   74,   75,
  183,  184,   79,   81,   83,   84,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  103,  110,  104,  104,
    0,  104,  104,  104,  104,  104,  104,  104,  104,  104,
    0,  104,  104,    0,  104,   31,  104,    0,  104,    0,
  104,    0,  104,  104,    0,  104,  104,    0,  104,    0,
   31,    0,   31,  104,  104,  104,  103,  103,  109,    0,
  103,  103,    0,    0,    0,    0,    0,    0,   31,    0,
    0,    0,    0,    0,    0,    0,  110,    0,  110,    0,
  103,   36,   37,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   38,    0,    0,  109,  109,
    0,    0,  109,    0,   41,    0,    0,    0,    0,   39,
  169,   40,    0,    0,    0,    0,   43,   44,   45,    0,
    0,    0,  109,    0,   36,   37,    0,   36,   37,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   38,  103,
    0,  103,   45,    0,   41,    0,    0,    0,   41,   41,
    0,    0,   39,  172,   40,   39,    0,   40,    0,   43,
   44,   45,   43,   44,   45,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  109,   45,  109,    0,    0,   45,   45,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   41,    0,    0,
    0,    0,   42,    0,    0,    0,    0,    0,    0,   47,
  110,  110,    0,  110,  110,  110,  110,  110,  110,  110,
  110,  110,    0,  110,  110,  110,  110,   41,  110,   41,
  110,    0,  110,    0,  110,  110,    0,  110,  110,    0,
  110,    0,    0,    0,    0,  110,  110,  110,    0,   47,
    0,    0,    0,   47,   47,    0,    0,    0,    0,   51,
    0,    0,    0,    0,    0,   45,    0,   45,    0,    0,
    0,    0,    0,  103,  103,    0,  103,  103,  103,  103,
  103,  103,  103,  103,  103,    0,  103,  103,    0,  103,
    0,  103,    0,  103,    0,  103,    0,  103,  103,   51,
  103,  103,    0,  103,   51,    0,    0,    0,  103,  103,
  103,    0,    0,    0,   49,  109,  109,    0,  109,  109,
  109,  109,  109,  109,  109,  109,  109,    0,  109,  109,
  109,  109,   47,  109,   47,  109,    0,  109,    0,  109,
  109,    0,  109,  109,    0,  109,    0,    0,    0,    0,
  109,  109,  109,    0,   49,    0,    0,    0,   49,   49,
    0,   41,   41,    0,   41,   41,    0,   41,   41,   41,
   41,   41,    0,    0,    0,   41,    0,    0,    0,   41,
    0,   41,   51,   41,   51,   41,   41,    0,   41,   41,
    0,   41,    0,    0,    0,    0,   41,   41,   41,   45,
   45,    0,   45,   45,    0,   45,   45,   45,   45,   45,
    0,    0,    0,   45,   36,   37,    0,   45,    0,   45,
    0,   45,    0,   45,   45,    0,   45,   45,   38,   45,
    0,    0,    0,    0,   45,   45,   45,   49,    0,   49,
    0,    0,   39,  174,   40,    0,    0,    0,   67,   43,
   44,   45,    0,   67,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  143,  141,    0,   47,   47,  143,   47,
   47,    0,   47,   47,   47,   47,   47,    0,    0,    0,
   47,    0,    0,    0,   47,    0,   47,    0,   47,    0,
   47,   47,    0,   47,   47,    0,   47,    0,    0,    0,
    0,   47,   47,   47,  128,    0,    0,  128,    0,  128,
  128,    0,  128,    0,  128,    0,   51,   51,    0,   51,
   51,    0,   51,   51,   51,   51,   51,  128,    0,  128,
   51,   67,    0,   67,   51,    0,   51,    0,   51,    0,
   51,   51,    0,   51,   51,    0,   51,    0,    0,    0,
    0,   51,   51,   51,    0,    0,    0,    0,    0,  128,
    0,    0,  128,    0,  128,  128,    0,  128,    0,  128,
    0,   49,   49,  128,   49,   49,    0,   49,   49,   49,
   49,   49,  128,    0,  128,   49,    0,    0,    0,   49,
  128,   49,  128,   49,    0,   49,   49,    0,   49,   49,
    0,   49,    0,    0,    0,    0,   49,   49,   49,    0,
  128,    0,    0,  128,  128,  128,  128,  128,  128,    0,
  128,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  128,    0,  128,    0,  128,    0,    0,
    0,    0,    0,    0,    0,  128,    0,  128,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   68,    0,
    0,    0,    0,   68,    0,   67,   67,    0,   67,   55,
   67,   67,   67,   67,   67,   67,    0,    0,   55,   67,
  143,  143,    0,   67,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   67,  143,   67,  128,    0,  128,    0,
   67,   67,   67,    0,    0,    0,    0,    0,  143,    0,
  143,    0,    0,   66,    0,  143,  143,  143,   66,    0,
    0,    0,    0,    0,  128,  128,    0,  128,  128,  128,
  128,  128,  128,  128,  128,  128,    0,  128,  128,  128,
  128,   68,  128,   68,    0,    0,    0,    0,    0,    0,
    0,    0,  128,    0,  128,  128,  128,  128,  128,  128,
    0,    0,    0,    0,   69,    0,    0,    0,    0,   69,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  128,
  128,    0,  128,  128,  128,  128,  128,  128,  128,  128,
    0,    0,  128,  128,  128,  128,   66,  128,   66,    0,
    0,    0,    0,    0,    0,    0,    0,  128,    0,  128,
  128,  128,  128,  128,  128,   84,    0,    0,    0,    0,
   84,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  128,  128,    0,  128,  128,  128,  128,  128,  128,  128,
  128,  128,    0,  128,  128,  128,  128,   69,  128,   69,
  128,    0,  128,    0,  128,  128,    0,  128,  128,    0,
  128,  128,  128,  128,  128,  128,   82,    0,    0,    0,
    0,   82,    0,    0,    0,   68,   68,    0,   68,   56,
   68,   68,   68,   68,   68,   68,    0,    0,   56,   68,
    0,    0,    0,   68,    0,    0,    0,    0,   84,    0,
   84,    0,    0,   68,    0,   68,    0,    0,    0,    0,
   68,   68,   68,   85,    0,    0,    0,    0,   85,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   66,   66,    0,   66,   54,   66,   66,   66,   66,   66,
   66,    0,    0,   54,   66,    0,    0,    0,   66,   82,
    0,   82,    0,    0,    0,    0,    0,    0,   66,    0,
   66,    0,    0,    0,   83,   66,   66,   66,    0,   83,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   69,   69,    0,   69,   57,   69,   69,   69,   69,
   69,   69,    0,    0,   57,   69,   85,    0,   85,   69,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   69,
    0,   69,    0,    0,    0,   92,   69,   69,   69,    0,
   92,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   84,   84,    0,   84,   60,   84,   84,   84,
   84,   84,   84,    0,    0,   60,   84,   83,    0,   83,
   84,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   84,    0,   84,    0,    0,    0,   86,   84,   84,   84,
    0,   86,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   82,   82,    0,   82,   58,   82,   82,
   82,   82,   82,   82,    0,    0,   58,   82,   92,    0,
   92,   82,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   82,    0,   82,    0,    0,    0,   91,   82,   82,
   82,    0,   91,    0,    0,    0,    0,    0,    0,    0,
   85,   85,    0,   85,   61,   85,   85,   85,   85,   85,
   85,    0,    0,   61,   85,    0,    0,    0,   85,   86,
    0,   86,    0,    0,    0,    0,    0,    0,   85,    0,
   85,    0,    0,    0,   96,   85,   85,   85,    0,   96,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   83,   83,    0,   83,   59,   83,   83,   83,   83,
   83,   83,    0,    0,   59,   83,    0,    0,    0,   83,
   91,    0,   91,    0,    0,    0,    0,    0,    0,   83,
    0,   83,    0,    0,    0,   94,   83,   83,   83,    0,
   94,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   92,   92,    0,   92,   92,   92,   92,   92,
   92,   92,   92,    0,    0,   92,   92,   96,    0,   96,
   92,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   92,    0,   92,    0,    0,    0,   95,   92,   92,   92,
    0,   95,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   86,   86,    0,   86,   64,   86,   86,
   86,   86,   86,   86,    0,    0,   64,   86,   94,    0,
   94,   86,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   86,    0,   86,    0,    0,    0,   87,   86,   86,
   86,    0,   87,    0,    0,    0,    0,    0,   41,    0,
    0,    0,    0,   42,   91,   91,    0,   91,   91,   91,
   91,   91,   91,   91,   91,    0,    0,   91,   91,   95,
    0,   95,   91,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   91,    0,   91,    0,    0,    0,   98,   91,
   91,   91,    0,   98,    0,    0,    0,    0,    0,    0,
    0,   96,   96,    0,   96,   96,   96,   96,   96,   96,
   96,   96,    0,    0,   96,   96,    0,    0,    0,   96,
   87,    0,   87,    0,    0,    0,    0,    0,    0,   96,
    0,   96,    0,    0,    0,   38,   96,   96,   96,    0,
   38,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   94,   94,    0,   94,   94,   94,   94,   94,
   94,   94,   94,    0,    0,   94,   94,    0,    0,    0,
   94,   98,    0,   98,    0,    0,    0,    0,    0,    0,
   94,    0,   94,    0,    0,    0,   37,   94,   94,   94,
    0,   37,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   95,   95,    0,   95,   95,   95,   95,
   95,   95,   95,   95,    0,    0,   95,   95,   38,    0,
   38,   95,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   95,    0,   95,    0,    0,    0,   70,   95,   95,
   95,    0,   70,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   87,   87,    0,   87,   62,   87,
   87,   87,   87,   87,   87,   36,   37,   62,   87,   37,
    0,   37,   87,    0,    0,    0,    0,    0,    0,   38,
   74,    0,   87,    0,   87,   74,    0,    0,    0,   87,
   87,   87,    0,   39,    0,   40,    0,    0,    0,    0,
   43,   44,   45,    0,    0,   98,   98,    0,   98,   98,
   98,   98,   98,   98,   98,   98,    0,    0,   98,   98,
   70,    0,   70,   98,    0,    0,    0,    0,    0,    0,
    0,   75,    0,   98,    0,   98,   75,    0,    0,    0,
   98,   98,   98,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   38,   38,    0,   38,   38,    0,   38,   38,
   38,   38,   38,   74,    0,   74,   38,    0,    0,    0,
   38,    0,    0,    0,    0,    0,    0,    0,    0,   40,
   38,    0,   38,    0,    0,    0,   41,   38,   38,   38,
    0,   42,    0,   69,   70,    0,    0,    0,    0,    0,
    0,    0,    0,   37,   37,    0,   37,   37,    0,   37,
   37,   37,   37,   37,   75,    0,   75,   37,    0,    0,
    0,   37,    0,    0,    0,    0,    0,   41,    0,    0,
   39,   37,   42,   37,    0,    0,    0,    0,   37,   37,
   37,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   70,   70,    0,   70,   70,   70,
   70,   70,   70,   70,   70,    0,    0,    0,   70,  153,
    0,  154,   70,    0,    0,    0,   71,    0,    0,    0,
    0,   71,   70,    0,   70,    0,    0,    0,  162,   70,
   70,   70,    0,    0,    0,    0,    0,   74,   74,    0,
   74,   74,   74,   74,   74,   74,   74,   74,    0,    0,
  153,   74,  192,    0,   41,   74,    0,    0,    0,   42,
    0,    0,    0,    0,    0,   74,  162,   74,    0,    0,
  198,  199,   74,   74,   74,    0,    0,    0,  206,    0,
    0,    0,    0,    0,  162,    0,    0,    0,   75,   75,
    0,   75,   75,   75,   75,   75,   75,   75,   75,   71,
  199,   71,   75,  162,  162,    0,   75,    0,    0,    0,
    0,    0,    0,  162,    0,    0,   75,    0,   75,    0,
    0,    0,    0,   75,   75,   75,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  153,    0,    0,
    0,    0,    0,   36,   37,    0,  145,  146,    0,  147,
  148,  149,  150,  151,    0,    0,    0,   38,    0,    0,
    0,  152,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   39,    0,   40,    0,    0,    0,    0,   43,   44,
   45,    0,    0,    0,   36,   37,    0,  145,  146,    0,
  147,  148,  149,  150,  151,    0,    0,    0,   38,    0,
    0,    0,  152,    0,    0,   46,    0,    0,    0,    0,
    0,    0,   39,    0,   40,    0,    0,   65,    0,   43,
   44,   45,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   71,   71,    0,   71,   71,    0,   71,
   71,   71,   71,   71,    0,    0,    0,   71,    0,    0,
    0,   71,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   71,    0,   71,    0,    0,    0,    0,   71,   71,
   71,   36,   37,    0,  145,  146,    0,  147,  148,  149,
  150,  151,  119,    0,    0,   38,    0,  121,    0,  152,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   39,
    0,   40,    0,    0,    0,  136,   43,   44,   45,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  164,    0,
    0,  166,    0,    0,    0,  170,    0,  173,  176,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  193,  194,    0,  196,    0,  201,
  202,    0,    0,  204,  205,    0,  176,  176,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  216,    0,  218,    0,
    0,    0,    0,    0,    0,    0,    0,  223,
};
static const YYINT yycheck[] = {                         40,
    0,    0,   44,   61,   45,   41,   41,   41,  125,   61,
   72,   44,   44,   60,   44,   64,  125,   28,   44,  259,
  261,  292,   37,  268,  292,  136,  137,   42,  273,  270,
  279,   61,   47,   58,  274,   61,  276,   37,  195,   91,
   40,   41,   42,   43,   44,   45,    0,   47,  110,   96,
  112,   62,  292,  164,   44,  293,  294,  214,  215,  292,
   60,   61,   62,   40,   64,  277,  128,  224,  123,  281,
  282,   61,  284,  281,  282,    7,  125,    9,   10,  285,
   41,  287,  123,   43,  125,   45,   40,   41,    0,   43,
   44,   45,  190,  191,  285,   44,   64,  278,  292,  292,
  273,  272,  113,   40,   93,  292,   60,  292,   62,   44,
   64,   61,   58,  125,  292,   41,  123,   40,  292,  284,
   41,   40,  278,  123,  286,  125,   40,   44,   40,   41,
  262,   43,   44,   45,   44,   44,   44,   41,   41,   44,
   96,   61,   44,  203,  132,  153,   71,   43,   60,   45,
   62,    0,   64,  134,  165,   73,   61,   38,  181,   86,
  211,   85,   90,   -1,   60,   -1,   62,   -1,   -1,  123,
   -1,  125,  281,  282,   -1,  292,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  292,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   40,   41,   -1,   -1,   44,   45,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   41,   -1,   -1,
   -1,  123,   -1,  125,   -1,   64,  257,  258,   -1,  260,
  261,  262,  263,  264,  265,  266,  267,   -1,   -1,  270,
  271,  273,  281,  282,  275,  293,  294,  273,  273,  273,
  273,  273,   -1,  292,  285,   -1,  287,   -1,   -1,   -1,
   -1,  292,  293,  294,   40,   -1,   -1,  257,  258,   45,
  260,  261,  262,  263,  264,  265,  266,  267,  268,   -1,
  270,  271,  272,  273,  123,  275,  125,  277,   -1,  279,
  279,  281,  282,   -1,  284,  285,   -1,  287,  288,  289,
  290,  291,  292,  293,  294,  295,  296,   40,   -1,   -1,
   40,   -1,   45,  257,  258,   45,  260,  261,  262,  263,
  264,  265,  266,  267,  268,   -1,  270,  271,  272,  273,
   -1,  275,   -1,  277,   -1,  279,   -1,  281,  282,   -1,
  284,  285,   -1,  287,  288,  289,  290,  291,  292,  293,
  294,   -1,   -1,    0,   -1,  257,  258,   -1,  260,  261,
  262,  263,  264,  265,  266,  267,  268,   -1,  270,  271,
  272,  273,   -1,  275,   -1,  277,   -1,  279,   -1,  281,
  282,   -1,  284,  285,   -1,  287,  288,  289,  290,  291,
  292,  293,  294,   40,   41,   -1,   -1,   44,  293,  294,
  295,  296,  288,  289,  290,  291,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,    0,   64,  257,  258,
   -1,  260,  261,  262,  263,  264,  265,  266,  267,  268,
   -1,  270,  271,   -1,  273,  259,  275,   -1,  277,   -1,
  279,   -1,  281,  282,   -1,  284,  285,   -1,  287,   -1,
  274,   -1,  276,  292,  293,  294,   40,   41,    0,   -1,
   44,   45,   -1,   -1,   -1,   -1,   -1,   -1,  292,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  123,   -1,  125,   -1,
   64,  257,  258,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  271,   -1,   -1,   40,   41,
   -1,   -1,   44,   -1,    0,   -1,   -1,   -1,   -1,  285,
  286,  287,   -1,   -1,   -1,   -1,  292,  293,  294,   -1,
   -1,   -1,   64,   -1,  257,  258,   -1,  257,  258,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  271,  123,
   -1,  125,    0,   -1,   40,   -1,   -1,   -1,   44,   45,
   -1,   -1,  285,  286,  287,  285,   -1,  287,   -1,  292,
  293,  294,  292,  293,  294,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  123,   40,  125,   -1,   -1,   44,   45,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   40,   -1,   -1,
   -1,   -1,   45,   -1,   -1,   -1,   -1,   -1,   -1,    0,
  257,  258,   -1,  260,  261,  262,  263,  264,  265,  266,
  267,  268,   -1,  270,  271,  272,  273,  123,  275,  125,
  277,   -1,  279,   -1,  281,  282,   -1,  284,  285,   -1,
  287,   -1,   -1,   -1,   -1,  292,  293,  294,   -1,   40,
   -1,   -1,   -1,   44,   45,   -1,   -1,   -1,   -1,    0,
   -1,   -1,   -1,   -1,   -1,  123,   -1,  125,   -1,   -1,
   -1,   -1,   -1,  257,  258,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,  268,   -1,  270,  271,   -1,  273,
   -1,  275,   -1,  277,   -1,  279,   -1,  281,  282,   40,
  284,  285,   -1,  287,   45,   -1,   -1,   -1,  292,  293,
  294,   -1,   -1,   -1,    0,  257,  258,   -1,  260,  261,
  262,  263,  264,  265,  266,  267,  268,   -1,  270,  271,
  272,  273,  123,  275,  125,  277,   -1,  279,   -1,  281,
  282,   -1,  284,  285,   -1,  287,   -1,   -1,   -1,   -1,
  292,  293,  294,   -1,   40,   -1,   -1,   -1,   44,   45,
   -1,  257,  258,   -1,  260,  261,   -1,  263,  264,  265,
  266,  267,   -1,   -1,   -1,  271,   -1,   -1,   -1,  275,
   -1,  277,  123,  279,  125,  281,  282,   -1,  284,  285,
   -1,  287,   -1,   -1,   -1,   -1,  292,  293,  294,  257,
  258,   -1,  260,  261,   -1,  263,  264,  265,  266,  267,
   -1,   -1,   -1,  271,  257,  258,   -1,  275,   -1,  277,
   -1,  279,   -1,  281,  282,   -1,  284,  285,  271,  287,
   -1,   -1,   -1,   -1,  292,  293,  294,  123,   -1,  125,
   -1,   -1,  285,  286,  287,   -1,   -1,   -1,   40,  292,
  293,  294,   -1,   45,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   40,   41,   -1,  257,  258,   45,  260,
  261,   -1,  263,  264,  265,  266,  267,   -1,   -1,   -1,
  271,   -1,   -1,   -1,  275,   -1,  277,   -1,  279,   -1,
  281,  282,   -1,  284,  285,   -1,  287,   -1,   -1,   -1,
   -1,  292,  293,  294,   37,   -1,   -1,   40,   -1,   42,
   43,   -1,   45,   -1,   47,   -1,  257,  258,   -1,  260,
  261,   -1,  263,  264,  265,  266,  267,   60,   -1,   62,
  271,  123,   -1,  125,  275,   -1,  277,   -1,  279,   -1,
  281,  282,   -1,  284,  285,   -1,  287,   -1,   -1,   -1,
   -1,  292,  293,  294,   -1,   -1,   -1,   -1,   -1,   37,
   -1,   -1,   40,   -1,   42,   43,   -1,   45,   -1,   47,
   -1,  257,  258,    0,  260,  261,   -1,  263,  264,  265,
  266,  267,   60,   -1,   62,  271,   -1,   -1,   -1,  275,
  123,  277,  125,  279,   -1,  281,  282,   -1,  284,  285,
   -1,  287,   -1,   -1,   -1,   -1,  292,  293,  294,   -1,
   37,   -1,   -1,   40,   41,   42,   43,   44,   45,   -1,
   47,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   60,   -1,   62,   -1,   64,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  123,   -1,  125,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   40,   -1,
   -1,   -1,   -1,   45,   -1,  257,  258,   -1,  260,  261,
  262,  263,  264,  265,  266,  267,   -1,   -1,  270,  271,
  257,  258,   -1,  275,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  285,  271,  287,  123,   -1,  125,   -1,
  292,  293,  294,   -1,   -1,   -1,   -1,   -1,  285,   -1,
  287,   -1,   -1,   40,   -1,  292,  293,  294,   45,   -1,
   -1,   -1,   -1,   -1,  257,  258,   -1,  260,  261,  262,
  263,  264,  265,  266,  267,  268,   -1,  270,  271,  272,
  273,  123,  275,  125,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  285,   -1,  287,  288,  289,  290,  291,  292,
   -1,   -1,   -1,   -1,   40,   -1,   -1,   -1,   -1,   45,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,
  258,   -1,  260,  261,  262,  263,  264,  265,  266,  267,
   -1,   -1,  270,  271,  272,  273,  123,  275,  125,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  285,   -1,  287,
  288,  289,  290,  291,  292,   40,   -1,   -1,   -1,   -1,
   45,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  257,  258,   -1,  260,  261,  262,  263,  264,  265,  266,
  267,  268,   -1,  270,  271,  272,  273,  123,  275,  125,
  277,   -1,  279,   -1,  281,  282,   -1,  284,  285,   -1,
  287,  288,  289,  290,  291,  292,   40,   -1,   -1,   -1,
   -1,   45,   -1,   -1,   -1,  257,  258,   -1,  260,  261,
  262,  263,  264,  265,  266,  267,   -1,   -1,  270,  271,
   -1,   -1,   -1,  275,   -1,   -1,   -1,   -1,  123,   -1,
  125,   -1,   -1,  285,   -1,  287,   -1,   -1,   -1,   -1,
  292,  293,  294,   40,   -1,   -1,   -1,   -1,   45,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  257,  258,   -1,  260,  261,  262,  263,  264,  265,  266,
  267,   -1,   -1,  270,  271,   -1,   -1,   -1,  275,  123,
   -1,  125,   -1,   -1,   -1,   -1,   -1,   -1,  285,   -1,
  287,   -1,   -1,   -1,   40,  292,  293,  294,   -1,   45,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,   -1,   -1,  270,  271,  123,   -1,  125,  275,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  285,
   -1,  287,   -1,   -1,   -1,   40,  292,  293,  294,   -1,
   45,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,   -1,   -1,  270,  271,  123,   -1,  125,
  275,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  285,   -1,  287,   -1,   -1,   -1,   40,  292,  293,  294,
   -1,   45,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  257,  258,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,   -1,   -1,  270,  271,  123,   -1,
  125,  275,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  285,   -1,  287,   -1,   -1,   -1,   40,  292,  293,
  294,   -1,   45,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  257,  258,   -1,  260,  261,  262,  263,  264,  265,  266,
  267,   -1,   -1,  270,  271,   -1,   -1,   -1,  275,  123,
   -1,  125,   -1,   -1,   -1,   -1,   -1,   -1,  285,   -1,
  287,   -1,   -1,   -1,   40,  292,  293,  294,   -1,   45,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,   -1,   -1,  270,  271,   -1,   -1,   -1,  275,
  123,   -1,  125,   -1,   -1,   -1,   -1,   -1,   -1,  285,
   -1,  287,   -1,   -1,   -1,   40,  292,  293,  294,   -1,
   45,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,   -1,   -1,  270,  271,  123,   -1,  125,
  275,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  285,   -1,  287,   -1,   -1,   -1,   40,  292,  293,  294,
   -1,   45,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  257,  258,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,   -1,   -1,  270,  271,  123,   -1,
  125,  275,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  285,   -1,  287,   -1,   -1,   -1,   40,  292,  293,
  294,   -1,   45,   -1,   -1,   -1,   -1,   -1,   40,   -1,
   -1,   -1,   -1,   45,  257,  258,   -1,  260,  261,  262,
  263,  264,  265,  266,  267,   -1,   -1,  270,  271,  123,
   -1,  125,  275,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  285,   -1,  287,   -1,   -1,   -1,   40,  292,
  293,  294,   -1,   45,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  257,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,   -1,   -1,  270,  271,   -1,   -1,   -1,  275,
  123,   -1,  125,   -1,   -1,   -1,   -1,   -1,   -1,  285,
   -1,  287,   -1,   -1,   -1,   40,  292,  293,  294,   -1,
   45,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  257,  258,   -1,  260,  261,  262,  263,  264,
  265,  266,  267,   -1,   -1,  270,  271,   -1,   -1,   -1,
  275,  123,   -1,  125,   -1,   -1,   -1,   -1,   -1,   -1,
  285,   -1,  287,   -1,   -1,   -1,   40,  292,  293,  294,
   -1,   45,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  257,  258,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,   -1,   -1,  270,  271,  123,   -1,
  125,  275,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  285,   -1,  287,   -1,   -1,   -1,   40,  292,  293,
  294,   -1,   45,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  257,  258,   -1,  260,  261,  262,
  263,  264,  265,  266,  267,  257,  258,  270,  271,  123,
   -1,  125,  275,   -1,   -1,   -1,   -1,   -1,   -1,  271,
   40,   -1,  285,   -1,  287,   45,   -1,   -1,   -1,  292,
  293,  294,   -1,  285,   -1,  287,   -1,   -1,   -1,   -1,
  292,  293,  294,   -1,   -1,  257,  258,   -1,  260,  261,
  262,  263,  264,  265,  266,  267,   -1,   -1,  270,  271,
  123,   -1,  125,  275,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   40,   -1,  285,   -1,  287,   45,   -1,   -1,   -1,
  292,  293,  294,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  257,  258,   -1,  260,  261,   -1,  263,  264,
  265,  266,  267,  123,   -1,  125,  271,   -1,   -1,   -1,
  275,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  284,
  285,   -1,  287,   -1,   -1,   -1,   40,  292,  293,  294,
   -1,   45,   -1,   44,   45,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  257,  258,   -1,  260,  261,   -1,  263,
  264,  265,  266,  267,  123,   -1,  125,  271,   -1,   -1,
   -1,  275,   -1,   -1,   -1,   -1,   -1,   40,   -1,   -1,
  284,  285,   45,  287,   -1,   -1,   -1,   -1,  292,  293,
  294,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  257,  258,   -1,  260,  261,  262,
  263,  264,  265,  266,  267,   -1,   -1,   -1,  271,  123,
   -1,  125,  275,   -1,   -1,   -1,   40,   -1,   -1,   -1,
   -1,   45,  285,   -1,  287,   -1,   -1,   -1,  139,  292,
  293,  294,   -1,   -1,   -1,   -1,   -1,  257,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,   -1,   -1,
  123,  271,  125,   -1,   40,  275,   -1,   -1,   -1,   45,
   -1,   -1,   -1,   -1,   -1,  285,  177,  287,   -1,   -1,
  181,  182,  292,  293,  294,   -1,   -1,   -1,  189,   -1,
   -1,   -1,   -1,   -1,  195,   -1,   -1,   -1,  257,  258,
   -1,  260,  261,  262,  263,  264,  265,  266,  267,  123,
  211,  125,  271,  214,  215,   -1,  275,   -1,   -1,   -1,
   -1,   -1,   -1,  224,   -1,   -1,  285,   -1,  287,   -1,
   -1,   -1,   -1,  292,  293,  294,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  123,   -1,   -1,
   -1,   -1,   -1,  257,  258,   -1,  260,  261,   -1,  263,
  264,  265,  266,  267,   -1,   -1,   -1,  271,   -1,   -1,
   -1,  275,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  285,   -1,  287,   -1,   -1,   -1,   -1,  292,  293,
  294,   -1,   -1,   -1,  257,  258,   -1,  260,  261,   -1,
  263,  264,  265,  266,  267,   -1,   -1,   -1,  271,   -1,
   -1,   -1,  275,   -1,   -1,   29,   -1,   -1,   -1,   -1,
   -1,   -1,  285,   -1,  287,   -1,   -1,   41,   -1,  292,
  293,  294,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  257,  258,   -1,  260,  261,   -1,  263,
  264,  265,  266,  267,   -1,   -1,   -1,  271,   -1,   -1,
   -1,  275,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  285,   -1,  287,   -1,   -1,   -1,   -1,  292,  293,
  294,  257,  258,   -1,  260,  261,   -1,  263,  264,  265,
  266,  267,  106,   -1,   -1,  271,   -1,  111,   -1,  275,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  285,
   -1,  287,   -1,   -1,   -1,  129,  292,  293,  294,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  142,   -1,
   -1,  145,   -1,   -1,   -1,  149,   -1,  151,  152,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  178,  179,   -1,  181,   -1,  183,
  184,   -1,   -1,  187,  188,   -1,  190,  191,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  210,   -1,  212,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  221,
};
#define YYFINAL 5
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 297
#define YYUNDFTOKEN 358
#define YYTRANSLATE(a) ((a) > YYMAXTOKEN ? YYUNDFTOKEN : (a))
#if YYDEBUG
static const char *const yyname[] = {

"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,"'%'",0,0,"'('","')'","'*'","'+'","','","'-'",0,"'/'",0,0,0,0,0,0,0,0,0,0,
"':'","';'","'<'","'='","'>'",0,"'@'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,"'['",0,"']'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,"'{'",0,"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"FALSE","TRUE","INT","RETURN","IF","ELSE",
"WHILE","BREAK","PRINT","READ","PRINTLN","TIMES","USE","UNLESS","NOT","AND",
"OR","REAL","PUTS","BOOL","FUNC","RIGHTARROW","CLASS","PRIVATE","PUBLIC",
"ABSTRACT","METH","VAR","DEC_CONST","LITERAL","REAL_DEC_CONST","GE","LE","NE",
"EQ","ID","INC","DEC","ADDASSIGN","SUBASSIGN","LOWER_THAN_ELSE",0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,"illegal-symbol",
};
static const char *const yyrule[] = {
"$accept : program",
"program : definitions",
"definitions : class definitions",
"definitions : func definitions",
"definitions : decl definitions",
"definitions :",
"meth_list : methodef meth_list",
"meth_list :",
"methodef : meth",
"$$1 :",
"class : modifier CLASS ID $$1 bodyclass",
"modifier :",
"modifier : PUBLIC",
"modifier : ABSTRACT",
"fields : field fields",
"fields :",
"field : '@' ID ':' type attrs",
"field : '@' ID ':' type '=' expr attrs",
"attrs : ',' ID attrs",
"attrs : ',' ID '=' expr attrs",
"attrs :",
"bodyclass : '{' fields meth_list '}'",
"$$2 :",
"$$3 :",
"meth : modifier ID $$2 '(' params ')' RIGHTARROW type $$3 body",
"$$4 :",
"$$5 :",
"func : FUNC ID $$4 '(' params ')' RIGHTARROW type $$5 body",
"params : formals type ID",
"params :",
"formals : formals type ID ','",
"formals :",
"type : INT",
"type : REAL",
"type : BOOL",
"type : ID",
"body : '{' decls stmts '}'",
"decls : decl_list decl",
"decls :",
"decl_list : decl_list decl",
"decl_list :",
"$$6 :",
"decl : VAR ID ':' type $$6 vars",
"$$7 :",
"decl : VAR ID ':' type '[' DEC_CONST ']' $$7 vars",
"$$8 :",
"decl : VAR ID ':' type '=' expr $$8 vars",
"$$9 :",
"vars : ',' ID $$9 vars",
"$$10 :",
"vars : ',' ID '=' expr $$10 vars",
"vars :",
"stmts : stmts stmt",
"stmts :",
"singlestmt : assign",
"singlestmt : addassign",
"singlestmt : subassign",
"singlestmt : listedassign",
"singlestmt : PRINT expr",
"singlestmt : PRINTLN expr",
"singlestmt : PRINT LITERAL",
"singlestmt : PRINTLN LITERAL",
"singlestmt : READ LITERAL ',' location",
"singlestmt : expr",
"singlestmt : PUTS inline",
"code :",
"stmt : assign",
"stmt : addassign",
"stmt : subassign",
"stmt : listedassign",
"stmt : RETURN expr",
"stmt : IF code '(' expr ')' stmt",
"$$11 :",
"stmt : IF code '(' expr ')' stmt ELSE $$11 stmt",
"stmt : singlestmt IF expr",
"stmt : singlestmt UNLESS expr",
"$$12 :",
"stmt : WHILE $$12 '(' expr ')' stmt",
"$$13 :",
"stmt : expr TIMES $$13 stmt",
"stmt : BREAK",
"stmt : block",
"stmt : PRINT expr",
"stmt : PRINTLN expr",
"stmt : PRINT LITERAL",
"stmt : PRINTLN LITERAL",
"stmt : PUTS inline",
"stmt : READ LITERAL ',' location",
"stmt : expr",
"inline : expr ',' inline",
"inline : LITERAL ',' inline",
"inline : expr",
"inline : LITERAL",
"block : '{' stmts '}'",
"addassign : location ADDASSIGN expr",
"subassign : location SUBASSIGN expr",
"assign : location '=' expr",
"assign : location '=' assign",
"listedassign : location ',' nestedassign ',' expr",
"nestedassign : location ',' nestedassign ',' expr",
"nestedassign : location '=' expr",
"method : ID",
"location : ID",
"expr : expr OR logAnd_expr",
"expr : logAnd_expr",
"logAnd_expr : logAnd_expr AND not_expr",
"logAnd_expr : not_expr",
"not_expr : NOT comp_expr",
"not_expr : comp_expr",
"comp_expr : add_expr relop add_expr",
"comp_expr : add_expr",
"relop : GE",
"relop : '>'",
"relop : LE",
"relop : '<'",
"relop : NE",
"relop : EQ",
"add_expr : add_expr addop term",
"add_expr : term",
"addop : '+'",
"addop : '-'",
"term : term mulop factor",
"term : factor",
"mulop : '*'",
"mulop : '/'",
"mulop : '%'",
"factor : incdec",
"factor : '(' expr ')'",
"factor : location",
"factor : DEC_CONST",
"factor : REAL_DEC_CONST",
"factor : TRUE",
"factor : FALSE",
"factor : method '(' actuals ')'",
"factor : '-' DEC_CONST",
"factor : '-' REAL_DEC_CONST",
"incdec : location INC",
"incdec : INC location",
"incdec : location DEC",
"incdec : DEC location",
"actuals : args expr",
"actuals :",
"args : args expr ','",
"args :",

};
#endif

int      yydebug;
int      yynerrs;

int      yyerrflag;
int      yychar;
YYSTYPE  yyval;
YYSTYPE  yylval;

/* define the initial stack-sizes */
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH  YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH  10000
#endif
#endif

#define YYINITSTACKSIZE 200

typedef struct {
    unsigned stacksize;
    YYINT    *s_base;
    YYINT    *s_mark;
    YYINT    *s_last;
    YYSTYPE  *l_base;
    YYSTYPE  *l_mark;
} YYSTACKDATA;
/* variables for the parser stack */
static YYSTACKDATA yystack;
#line 1936 "nectar_syntax"



void Init_Hash_Table(void)
{  int i;

   for(i=0; i<SYM_TABLE_SIZE; i++)
      ht.table[i]=NULL;
}


void Init_Array_Hash_Table(void)
{  int i,j;

   for(i=0; i<MAX_SYM_TABLES; i++){
        for(j=0; j<SYM_TABLE_SIZE; j++){
            arr_st[i].table[j]=NULL;
          }
     }
}


void push_wh(symbol *p)
{
   whiles[++TopOfWhile]=p;

}

void push_rt(symbol *p)
{
   returns[++TopOfRt]=p;
}

symbol *pop_rt(void)
{

   return(returns[TopOfRt--]);
}



void push_vs(symbol *p)
{
   vs[++TopOfStack]=p;
}

symbol* see_wh()
{
   return whiles[TopOfWhile];
}

symbol *pop_wh(void)
{
	if(TopOfWhile<0) return(NULL);
	symbol * temp;
	temp = whiles[TopOfWhile--];
	whiles[TopOfWhile+1] = NULL;

   return(temp);
}


symbol *pop_vs(void)
{

   return(vs[TopOfStack--]);
}

symbol *new_symbol(char *name){

   symbol *symbp;
   symbp=(symbol *)malloc(sizeof(symbol));
   memset(symbp,0,sizeof(symbol));
   strncpy(symbp->name,name,(strlen(name)>NAME_MAX)?NAME_MAX:strlen(name));


   symbp->timi=0;
   symbp->lvalue=1;
   symbp->arg = 0;
   symbp->mht = NULL;
   symbp->has_timi = 0;
   symbp->dcl_ptr = NULL;
   symbp->NextSymbol=NULL;
   symbp->PrevSymbol=NULL;
   return(symbp);
}

void add_method_dcl(symbol *symbp)
{  dcl *p,*q;

   q=(dcl *)malloc(sizeof(dcl));
   q->dcl_type=METHOD;
   q->num_params=numOfParams;
   p=symbp->dcl_ptr;
   if(!p)
      symbp->dcl_ptr=q;


}

void add_array_dcl(symbol *symbp, int size)
{  dcl *p,*q;

   q=(dcl *)malloc(sizeof(dcl));
   q->dcl_type=ARRAY;
   q->num_params=size;
   p=symbp->dcl_ptr;
   if(!p)
      symbp->dcl_ptr=q;


}

int is_integral(symbol *s){

	if(s){
		if(s->typos == INT)
			return(1);


	}

	return(0);

}

int set_class_types(symbol *symbp, int class_tipos)
{
   switch(class_tipos)
   {
      case INT:
         if(symbp->typos) return(1);
         symbp->typos=class_tipos;
      break;
	  case REAL:
         if(symbp->typos) return(1);
         symbp->typos=class_tipos;
      break;
	  case BOOL:
         if(symbp->typos) return(1);
         symbp->typos=class_tipos;
      break;
      case METHOD:
		 add_method_dcl(symbp);
         break;
   }
   return(0);
}


void Init_while_stack(){
	int i =0;
	for(;i<30; i++)
		whiles[i] = NULL;

}



void copy_attributes(symbol *dst, symbol *src)
{  symbol *p;
   int ret_v;

   if(src)
   {
     p=dst;
     if(src->typos)
         {
            ret_v=set_class_types(p,src->typos);
            if(ret_v)
            {
               printf("One type permitted\n");
               exit(1);
            }
         }
      }

}



int mkkey(char *s)
{  char *p;
   int athr=0;

   for(p=s; *p; p++) athr=athr+(*p);
   return (athr % SYM_TABLE_SIZE);
}

void addsymb(symbol *symbp, int gl)
{  int i;
   symbol *p;

    if(topOfSt == MAX_SYM_TABLES) {
			printf("Out of memory :( , the number of methods must be less than %d",MAX_SYM_TABLES); //if the number of methods is greater than MAX_SYM_TABLES constant
			exit(1);
			}

 if(gl ==1) {
   i=mkkey(symbp->name);
   p=ht.table[i];
   symbp->NextSymbol=p;
   symbp->PrevSymbol=NULL;
   symbp->mht= &arr_st[topOfSt];
   if(p) p->PrevSymbol=symbp;
   ht.table[i]=symbp;
   ht.numbsymbols++;
 }else {

   i=mkkey(symbp->name);
   p=arr_st[topOfSt].table[i];
   symbp->NextSymbol=p;
   symbp->PrevSymbol=NULL;
   if(p) p->PrevSymbol=symbp;
   arr_st[topOfSt].table[i]=symbp;
   arr_st[topOfSt].numbsymbols++;

}

}

symbol *findsymb(char *onoma, int gl)
{  int i;
   symbol *p;

   if(gl == 1){
   i=mkkey(onoma);
   p=ht.table[i];

   while(p && (strcmp(p->name,onoma) !=0)){
      p=p->NextSymbol;
}
}else {
    i=mkkey(onoma);
	 if(topOfSt == MAX_SYM_TABLES) {
			printf("Out of memory :( , the number of methods must be less than %d",MAX_SYM_TABLES); //if the number of methods is greater than MAX_SYM_TABLES constant
			exit(1);
			}
    p=arr_st[topOfSt].table[i];
    while(p && (strcmp(p->name,onoma) !=0))
       p=p->NextSymbol;


   }
 return(p);
}

void add_symbols_to_table(symbol *symbp, int gl)
{
      symbol *exists;
      exists=findsymb(symbp->name,gl);

      if( !exists )
      {
         addsymb(symbp,gl);

      }
           /* -- exists -- */
      else
      {
         printf("Error: '%s' redeclaration\n",symbp->name);
         exit(1);
      }

}

void discard_symbol(symbol *symbp)
{
   if(symbp)
   {


      symbp->PrevSymbol->NextSymbol = symbp->NextSymbol;
      symbp->NextSymbol->PrevSymbol = symbp->PrevSymbol;
	  symbp->PrevSymbol = NULL;
	  symbp->NextSymbol = NULL;

   }
}

void check_assignment(symbol *opnd1, symbol *opnd2)
{  symbol *p;

   if( !(opnd1->lvalue))
   {
      printf("Error: The left operand must be an lvalue (modifiable)\n");
      exit(1);
   }

   return;
}


void copy_value(symbol *dst, symbol *src)
{
   if(src->has_timi){

      if(src->has_timi == CONST_VAL){

		 switch (dst->typos){
			 case INT:

				dst->timi = src->timi;
				dst->has_timi=src->has_timi;

			 break;
			 case REAL:

				dst->dtimi = src->dtimi;
				dst->has_timi=src->has_timi;

			 break;
			 case BOOL:

				dst->timi = src->timi;
				dst->has_timi=src->has_timi;

			 break;

		 }

       }
   }
}

void copy_symbol(symbol *dst, symbol *src)
{
   if( src && dst){
		dst->typos=src->typos;
		copy_value(dst,src);
   }

}

AstNode *MkNode(int tipos,symbol *sn,
              AstNode *z0,AstNode *z1,AstNode *z2,AstNode *z3)
{  AstNode *p;

   p=(AstNode *)malloc(sizeof(AstNode));
   if(!p)
   {
      printf("Out of memory\n");
      exit(1);
   }
   else
   {
      p->NodeType=tipos;
      p->SymbolNode=sn;
      p->pAstNode[0]=z0;
      p->pAstNode[1]=z1;
      p->pAstNode[2]=z2;
      p->pAstNode[3]=z3;
      return(p);
   }
}

void check_while(symbol *pexp, symbol *pst)
{
   if(pexp->typos != INT)
   {
      printf("Error: The expression must have scalar type\n");
      exit(1);
   }

}



void check_ifelse(symbol *pexp, symbol *pst1, symbol *pst2)
{

   if( !is_integral(pexp))
   {
      printf("Error: The expression must have scalar type\n");
      exit(1);
   }
  // discard_symbol(pexp);
  // discard_symbol(pst1);
   //discard_symbol(pst2);
}

void preOrder(AstNode* p, int indent){
    if(p != NULL) {

		if (indent) {
			int i;
            for (i=0; i<=indent; i++){
				printf(" ");
			}
        }
        printf("%s\n", p->NodeType);
        if(p->pAstNode[0]) preOrder(p->pAstNode[0], indent+8);
        if(p->pAstNode[1]) preOrder(p->pAstNode[1], indent+8);
        if(p->pAstNode[2]) preOrder(p->pAstNode[2], indent+8);

    }
}



void Show_Hash_Table(void)
{
	int i,j;

	printf("\n------------- METHODS ---------\n");
	for(i=0; i<SYM_TABLE_SIZE; i++){

		printf("%s ",ht.table[i]) ;
	}
	printf("\n------------- VARIABLES ---------\n");

	for (i=0; i<MAX_SYM_TABLES ;i++){
		for (j=0; j<SYM_TABLE_SIZE; j++){
			printf("%s ",arr_st[i].table[j]) ;
		}
		printf("\n");
	}


}





symbol *check_logic_op(symbol *opnd1, symbol *opnd2)
{  symbol *p;

   if(( !is_integral(opnd1) ) || ( !is_integral(opnd2) ))
   {
      printf("Error: Both operands must be integers\n");

      exit(1);
   }
   p=new_symbol("");
   p->typos=INT;
   p->lvalue=0;
   p->has_timi=0;

   if((opnd1->has_timi==CONST_VAL) && (opnd1->has_timi==CONST_VAL))
         p->has_timi=CONST_VAL;

   if((opnd1->sclass==CONSTANT) && (opnd2->sclass==CONSTANT))
      p->sclass=CONSTANT;

   return(p);
}


symbol *check_muldiv_arithm_op(symbol *opnd1, symbol *opnd2)
{  symbol *p;

   if(( !is_integral(opnd1) ) || ( !is_integral(opnd2) ))
   {
      printf("Error: Both operands must be integers\n");
      exit(1);
   }
   p=new_symbol("");
   p->typos=INT;
   p->lvalue=0;
   p->has_timi=0;
   if((opnd1->has_timi==CONST_VAL) && (opnd1->has_timi==CONST_VAL))
         p->has_timi=CONST_VAL;

   if((opnd1->sclass==CONSTANT) && (opnd2->sclass==CONSTANT))
      p->sclass=CONSTANT;

   return(p);
}

int isSuperType(int type1, int type2){

	switch(type1){

		case INT:
			switch(type2){

				case INT:
					 return(1);
				break;
				case REAL:
					 return(0);
				break;
				case BOOL:
					 return(0);
				break;
			}
		break;
		case REAL:
			switch(type2){

				case INT:
					 return(1);
				break;
				case REAL:
					 return(1);
				break;
				case BOOL:
					 return(0);
				break;

			}
		break;
		case BOOL:
			switch(type2){

					case INT:
						 return(0);
					break;
					case REAL:
						 return(0);
					break;
					case BOOL:
						 return(1);
					break;

				}
		break;


	}


}


symbol *check_addsub_arithm_op(symbol *opnd1, symbol *opnd2)
{  symbol *p;
   dcl *d1, *d2;

   p=new_symbol("");

   if(is_integral(opnd1) && is_integral(opnd2))
   {
      p->typos=opnd1->typos;
	 /* if(opnd1->has_timi)
		{
			if(opnd1->has_timi == CONST_VAL)
				p->timi = opnd1->timi;
			p->has_timi=opnd1->has_timi;
		}*/
	   if((opnd1->has_timi==CONST_VAL) && (opnd1->has_timi==CONST_VAL))
         p->has_timi=CONST_VAL;

      if((opnd1->sclass==CONSTANT) && (opnd2->sclass==CONSTANT))
         p->sclass=CONSTANT;
   }
   else
   {
      printf("Error: Both operands must be integers\n");
      exit(1);
   }

   p->lvalue=0;


   return(p);
}


void yyerror(char *s)
{
   fputs(s,stderr); putc('\n',stderr);
}
#line 1571 "y.tab.c"

#if YYDEBUG
#include <stdio.h>		/* needed for printf */
#endif

#include <stdlib.h>	/* needed for malloc, etc */
#include <string.h>	/* needed for memset */

/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack(YYSTACKDATA *data)
{
    int i;
    unsigned newsize;
    YYINT *newss;
    YYSTYPE *newvs;

    if ((newsize = data->stacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return YYENOMEM;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;

    i = (int) (data->s_mark - data->s_base);
    newss = (YYINT *)realloc(data->s_base, newsize * sizeof(*newss));
    if (newss == 0)
        return YYENOMEM;

    data->s_base = newss;
    data->s_mark = newss + i;

    newvs = (YYSTYPE *)realloc(data->l_base, newsize * sizeof(*newvs));
    if (newvs == 0)
        return YYENOMEM;

    data->l_base = newvs;
    data->l_mark = newvs + i;

    data->stacksize = newsize;
    data->s_last = data->s_base + newsize - 1;
    return 0;
}

#if YYPURE || defined(YY_NO_LEAKS)
static void yyfreestack(YYSTACKDATA *data)
{
    free(data->s_base);
    free(data->l_base);
    memset(data, 0, sizeof(*data));
}
#else
#define yyfreestack(data) /* nothing */
#endif

#define YYABORT  goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR  goto yyerrlab

int
YYPARSE_DECL()
{
    int yym, yyn, yystate;
#if YYDEBUG
    const char *yys;

    if ((yys = getenv("YYDEBUG")) != 0)
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = YYEMPTY;
    yystate = 0;

#if YYPURE
    memset(&yystack, 0, sizeof(yystack));
#endif

    if (yystack.s_base == NULL && yygrowstack(&yystack) == YYENOMEM) goto yyoverflow;
    yystack.s_mark = yystack.s_base;
    yystack.l_mark = yystack.l_base;
    yystate = 0;
    *yystack.s_mark = 0;

yyloop:
    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = YYLEX) < 0) yychar = YYEOF;
#if YYDEBUG
        if (yydebug)
        {
            yys = yyname[YYTRANSLATE(yychar)];
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
        {
            goto yyoverflow;
        }
        yystate = yytable[yyn];
        *++yystack.s_mark = yytable[yyn];
        *++yystack.l_mark = yylval;
        yychar = YYEMPTY;
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;

    YYERROR_CALL("syntax error");

    goto yyerrlab;

yyerrlab:
    ++yynerrs;

yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yystack.s_mark]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yystack.s_mark, yytable[yyn]);
#endif
                if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
                {
                    goto yyoverflow;
                }
                yystate = yytable[yyn];
                *++yystack.s_mark = yytable[yyn];
                *++yystack.l_mark = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yystack.s_mark);
#endif
                if (yystack.s_mark <= yystack.s_base) goto yyabort;
                --yystack.s_mark;
                --yystack.l_mark;
            }
        }
    }
    else
    {
        if (yychar == YYEOF) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = yyname[YYTRANSLATE(yychar)];
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = YYEMPTY;
        goto yyloop;
    }

yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    if (yym)
        yyval = yystack.l_mark[1-yym];
    else
        memset(&yyval, 0, sizeof yyval);
    switch (yyn)
    {
case 1:
#line 87 "nectar_syntax"
	{

		     p1 = findsymb("main",1);/*Every program in coral language must have a main function*/
		     if(!p1) {
					printf("Error : 'main' function not found");
					exit(1);
				}

			 TreeRoot=MkNode(astProgram,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);


        }
break;
case 2:
#line 104 "nectar_syntax"
	{ yyval.stnode=MkNode(astClassDef,NULL,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL,NULL); }
break;
case 3:
#line 105 "nectar_syntax"
	{ yyval.stnode=MkNode(astFuncDef,NULL,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL,NULL); }
break;
case 4:
#line 106 "nectar_syntax"
	{ yyval.stnode=MkNode(astDeclDef,NULL,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL,NULL); }
break;
case 5:
#line 107 "nectar_syntax"
	{ yyval.stnode=MkNode(astEmptyDef,NULL,NULL,NULL,NULL,NULL); }
break;
case 6:
#line 112 "nectar_syntax"
	{yyval.stnode=MkNode(astMethSeq,NULL,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL,NULL); }
break;
case 7:
#line 114 "nectar_syntax"
	{ yyval.stnode=MkNode(astEmptyMethList,NULL,NULL,NULL,NULL,NULL); }
break;
case 8:
#line 117 "nectar_syntax"
	{ yyval.stnode=yystack.l_mark[0].stnode;}
break;
case 9:
#line 121 "nectar_syntax"
	{

         strcat(CLASS_NAME,yystack.l_mark[0].ystr);
         p1 = pop_vs();

         p2 = new_symbol(CLASS_NAME);
         p2->accessor = p1->accessor;
         p2->lvalue = 0;

         /*Check if main method have parameters*/
         if((strcmp(p2->name,"Object") == 0)){

           printf("Error: Object class already exists\n");
           exit(1);
         }

         add_symbols_to_table(p2,1);

         if(topOfSt == MAX_SYM_TABLES) {
  				printf("Out of memory :( , the number of classes must be less than %d",MAX_SYM_TABLES); /*if the number of methods is greater than MAX_SYM_TABLES constant*/
  				exit(1);
  			 }


       }
break;
case 10:
#line 145 "nectar_syntax"
	{

         yyval.stnode=MkNode(astClass,p2,yystack.l_mark[0].stnode,NULL,NULL,NULL);

       }
break;
case 11:
#line 153 "nectar_syntax"
	{
           yyval.stnode=MkNode(astPrivateClassMod,NULL,NULL,NULL,NULL,NULL);
           p1 = new_symbol(""); /*create symbol*/
 	         p1->accessor = PRIVATE_ACC;
 	         push_vs(p1);
          }
break;
case 12:
#line 159 "nectar_syntax"
	{
           printf("modifier\n");
           yyval.stnode=MkNode(astPublicClassMod,NULL,NULL,NULL,NULL,NULL);
           p1 = new_symbol(""); /*create symbol*/
           p1->accessor = PUBLIC_ACC;
           push_vs(p1);
         }
break;
case 13:
#line 166 "nectar_syntax"
	{
           yyval.stnode=MkNode(astAbstractClassMod,NULL,NULL,NULL,NULL,NULL);
           p1 = new_symbol(""); /*create symbol*/
 	         p1->accessor = ABSTRACT_ACC;
 	         push_vs(p1);
         }
break;
case 14:
#line 176 "nectar_syntax"
	{yyval.stnode=MkNode(astFields,NULL,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL,NULL);}
break;
case 15:
#line 177 "nectar_syntax"
	{yyval.stnode=MkNode(astEmptyFields,NULL,NULL,NULL,NULL,NULL);}
break;
case 16:
#line 180 "nectar_syntax"
	{

           p1 = pop_vs();
           p3 = new_symbol(yystack.l_mark[-3].ystr);
           p3->sclass = MEMORY;
           p3->typos = p1->typos;
           p3->accessor = PRIVATE_ACC;
           p3->lvalue = 0;
           add_symbols_to_table(p3,1);

          if(topOfSt == MAX_SYM_TABLES) {
            printf("Out of memory :( , the number of attributes must be less than %d",MAX_SYM_TABLES); /*if the number of methods is greater than MAX_SYM_TABLES constant*/
            exit(1);
          }

          yyval.stnode=MkNode(astField,p3,yystack.l_mark[0].stnode,NULL,NULL,NULL);


         }
break;
case 17:
#line 199 "nectar_syntax"
	{


           p1 = pop_vs();
           p2 = pop_vs();

           p4 = new_symbol(yystack.l_mark[-5].ystr);
           p4->sclass = MEMORY;
           p4->typos = p2->typos;
           p4->accessor = PRIVATE_ACC;
           p4->lvalue = 0;

           add_symbols_to_table(p4,0);

          if(topOfSt == MAX_SYM_TABLES) {
            printf("Out of memory :( , the number of attributes must be less than %d",MAX_SYM_TABLES); /*if the number of methods is greater than MAX_SYM_TABLES constant*/
            exit(1);
          }

           yyval.stnode=MkNode(astFieldAssign,p4,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL,NULL);


         }
break;
case 18:
#line 225 "nectar_syntax"
	{


           p1 = pop_vs();
           /*p2 = pop_vs();*/

           p3 = new_symbol(yystack.l_mark[0].stnode);
           p3->sclass = MEMORY;
           p3->typos = p1->typos;
           p3->accessor = PRIVATE_ACC;
           p3->lvalue = 0;

           add_symbols_to_table(p3,1);

          if(topOfSt == MAX_SYM_TABLES) {
            printf("Out of memory :( , the number of attributes must be less than %d",MAX_SYM_TABLES); /*if the number of methods is greater than MAX_SYM_TABLES constant*/
            exit(1);
          }


          yyval.stnode=MkNode(astAttrs,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);

          /*push_vs(p2);*/
          push_vs(p1);

        }
break;
case 19:
#line 252 "nectar_syntax"
	{

          p1 = pop_vs();
          p2 = pop_vs();
          /*p3 = pop_vs();*/

          p4 = new_symbol(yystack.l_mark[-2].ystr);
          p4->sclass = MEMORY;
          p4->typos = p2->typos;
          p4->accessor = PRIVATE_ACC;
          p4->lvalue = 0;

          add_symbols_to_table(p4,0);

          if(topOfSt == MAX_SYM_TABLES) {
           printf("Out of memory :( , the number of attributes must be less than %d",MAX_SYM_TABLES); /*if the number of methods is greater than MAX_SYM_TABLES constant*/
           exit(1);
          }

          yyval.stnode=MkNode(astAttrsAssign,p4,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL,NULL);

          /*push_vs(p3);*/
          push_vs(p2);

        }
break;
case 20:
#line 277 "nectar_syntax"
	{ yyval.stnode=MkNode(astEmptyAttrs,NULL,NULL,NULL,NULL,NULL); }
break;
case 21:
#line 283 "nectar_syntax"
	{yyval.stnode=MkNode(astBodyClass,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[-1].stnode,NULL,NULL);
       	 }
break;
case 22:
#line 290 "nectar_syntax"
	{

          strcat(METHOD_NAME,yystack.l_mark[0].ystr);
		      push_rt(new_symbol("method"));

        }
break;
case 23:
#line 295 "nectar_syntax"
	{

    			 p1 = pop_vs();
           p3 = pop_vs();
    			 p2 = new_symbol(METHOD_NAME);
    			 p2->lvalue = 0;

    			 set_class_types(p2,METHOD);
    			 copy_attributes(p2,p1);
           p2->accessor = p3->accessor;

    			 /*Check if main method have parameters*/
    			 if((strcmp(p2->name,"main") == 0) && (numOfParams>0)){

    				 printf("Error: The main method must have no parameters\n");
    				 exit(1);

    			  }

    			 /*Create a pseudonym for this method, which is important for code generation*/
    			 if(strcmp(p2->name,"main") !=0){
    				 strcpy(NUM_VAR_ARR, "@METH_");
    				 sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_METH);
    				 strcpy(p2->pseudonym, strcat(NUM_VAR_ARR, TEMP_NUM_VAR_ARR));
    				 NUM_METH++;
    			 }else{
    				strcpy(p2->pseudonym,"_main");
    			 }


    			 add_symbols_to_table(p2,0);

    			 if(topOfSt == MAX_SYM_TABLES) {
    				printf("Out of memory :( , the number of methods must be less than %d",MAX_SYM_TABLES); /*if the number of methods is greater than MAX_SYM_TABLES constant*/
    				exit(1);
    			 }



    			 strcpy(METHOD_NAME,"");
           /*push_vs(p1);*/
    			 push_vs(p2);
		 }
break;
case 24:
#line 339 "nectar_syntax"
	{

		/*Checking for return statement*/

		if( TopOfRt <= 0 || !returns[0] || !returns[1] || strcmp(returns[0]->name,"method") != 0 || strcmp(returns[1]->name,"return" )!=0) {
			printf("Error: Method '%s' has not return statement\n",yystack.l_mark[-7].stnode);
			exit(1);
		}

		pop_rt();
		pop_rt();


		p2 = pop_vs();


	 	yyval.stnode=MkNode(astMethLast,p2,yystack.l_mark[-5].stnode,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL);

		if(topOfSt < MAX_SYM_TABLES)
				topOfSt++;

		numOfParams =0; /*reset the number of parameters for the next method*/
		enableReturn=1;
		NUM_PAR =0;
		NUM_BYTES_VAR = 0;
	}
break;
case 25:
#line 369 "nectar_syntax"
	{

      		 strcat(METHOD_NAME,yystack.l_mark[0].ystr);
      		 push_rt(new_symbol("method"));

      		 }
break;
case 26:
#line 374 "nectar_syntax"
	{

      			 p1 = pop_vs();

      			 p2 = new_symbol(METHOD_NAME);
      			 p2->lvalue = 0;

      			 set_class_types(p2,METHOD);
      			 copy_attributes(p2,p1);


      			 /*Check if main method have parameters*/
      			 if((strcmp(p2->name,"main") == 0) && (numOfParams>0)){

      				 printf("Error: The main method must have no parameters\n");
      				 exit(1);

      			  }

      			 /*Create a pseudonym for this method, which is important for code generation*/
      			 if(strcmp(p2->name,"main") !=0){
      				 strcpy(NUM_VAR_ARR, "@METH_");
      				 sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_METH);
      				 strcpy(p2->pseudonym, strcat(NUM_VAR_ARR, TEMP_NUM_VAR_ARR));
      				 NUM_METH++;
      			 }else{
      				strcpy(p2->pseudonym,"_main");
      			 }


      			 add_symbols_to_table(p2,1);

      			 if(topOfSt == MAX_SYM_TABLES) {
      				printf("Out of memory :( , the number of methods must be less than %d",MAX_SYM_TABLES); /*if the number of methods is greater than MAX_SYM_TABLES constant*/
      				exit(1);
      			 }



      			 strcpy(METHOD_NAME,"");
            /* push_vs(p1);*/
             push_vs(p2);
      		 }
break;
case 27:
#line 418 "nectar_syntax"
	{

      		/*Checking for return statement*/

      		if( TopOfRt <= 0 || !returns[0] || !returns[1] || strcmp(returns[0]->name,"method") != 0 || strcmp(returns[1]->name,"return" )!=0) {
      			printf("Error: Method '%s' has not return statement\n",yystack.l_mark[-8].ystr);
      			exit(1);
      		}

      		pop_rt();
      		pop_rt();


      		p2 = pop_vs();



      	 	yyval.stnode=MkNode(astFuncLast,p2,yystack.l_mark[-2].stnode,yystack.l_mark[-5].stnode,yystack.l_mark[0].stnode,NULL);

      		if(topOfSt < MAX_SYM_TABLES)
      				topOfSt++;

      		numOfParams =0; /*reset the number of parameters for the next method*/
      		enableReturn=1;
      		NUM_PAR =0;
      		NUM_BYTES_VAR = 0;
      	}
break;
case 28:
#line 449 "nectar_syntax"
	{


         p2 = pop_vs();
	       p3 = new_symbol(yystack.l_mark[0].ystr);
         p3->arg = 1;
	       copy_attributes(p3,p2);

		     sprintf(METHOD_NAME_TEMP,"%d",p2->typos);
		     strcat(METHOD_NAME,METHOD_NAME_TEMP);

		     /*Create a pseudonym for this parameter, which is important for code generation*/

		     strcpy(NUM_VAR_ARR, "ebp + ");
		     sprintf(TEMP_NUM_VAR_ARR, "%d", 4 * (NUM_PAR + 2));
		     strcpy(p3->pseudonym, strcat(NUM_VAR_ARR, TEMP_NUM_VAR_ARR));
		     NUM_PAR ++;

	       add_symbols_to_table(p3,0);
	       yyval.stnode=MkNode(astParamSeq,p3,yystack.l_mark[-2].stnode,yystack.l_mark[-1].stnode,NULL,NULL);
		     numOfParams++;
         p3->index = numOfParams;
          }
break;
case 29:
#line 472 "nectar_syntax"
	{ yyval.stnode=MkNode(astParamEmpty,NULL,NULL,NULL,NULL,NULL);}
break;
case 30:
#line 477 "nectar_syntax"
	{

	     p2 = pop_vs();
	     p3 = new_symbol(yystack.l_mark[-1].ystr);
	     p3->arg = 1;
	     copy_attributes(p3,p2);

		   sprintf(METHOD_NAME_TEMP,"%d",p2->typos);
		   strcat(METHOD_NAME,METHOD_NAME_TEMP);

		   strcpy(NUM_VAR_ARR, "ebp + ");
		   sprintf(TEMP_NUM_VAR_ARR, "%d", 4 *(NUM_PAR+2));
		   strcpy(p3->pseudonym, strcat(NUM_VAR_ARR, TEMP_NUM_VAR_ARR));
		   NUM_PAR++;

	     add_symbols_to_table(p3,0);
	     yyval.stnode=MkNode(astFormalsSeq,p3,yystack.l_mark[-3].stnode,yystack.l_mark[-2].stnode,NULL,NULL);
		   numOfParams++;
       p3->index = numOfParams;
		 }
break;
case 31:
#line 497 "nectar_syntax"
	{ yyval.stnode=MkNode(astFormalsEmpty,NULL,NULL,NULL,NULL,NULL);}
break;
case 32:
#line 502 "nectar_syntax"
	{

          yyval.stnode=MkNode(astInt,NULL,NULL,NULL,NULL,NULL);
 	        p1 = new_symbol(""); /*create symbol*/
	        set_class_types(p1,yystack.l_mark[0].yint); /*the type of symbol is integer*/
	        push_vs(p1);

        }
break;
case 33:
#line 510 "nectar_syntax"
	{

          yyval.stnode=MkNode(astReal,NULL,NULL,NULL,NULL,NULL);
 	        p1 = new_symbol(""); /*create symbol*/
	        set_class_types(p1,yystack.l_mark[0].yint); /*the type of symbol is real*/
	        push_vs(p1);

         }
break;
case 34:
#line 518 "nectar_syntax"
	{

          yyval.stnode=MkNode(astBool,NULL,NULL,NULL,NULL,NULL);
 	        p1 = new_symbol(""); /*create symbol*/
	        set_class_types(p1,yystack.l_mark[0].yint); /*the type of symbol is integer*/
	        push_vs(p1);

        }
break;
case 35:
#line 526 "nectar_syntax"
	{

          yyval.stnode=MkNode(astPointer,NULL,NULL,NULL,NULL,NULL);
 	        p1 = new_symbol(""); /*create symbol*/
	       /* set_class_types(p1,$1); //the type of symbol is integer*/
	        push_vs(p1);

        }
break;
case 36:
#line 537 "nectar_syntax"
	{
	 yyval.stnode=MkNode(astBody,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[-1].stnode,NULL,NULL);}
break;
case 37:
#line 543 "nectar_syntax"
	{ yyval.stnode=MkNode(astDeclsSeq,NULL,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL,NULL);}
break;
case 38:
#line 544 "nectar_syntax"
	{ yyval.stnode=MkNode(astDeclsEmpty,NULL,NULL,NULL,NULL,NULL);}
break;
case 39:
#line 549 "nectar_syntax"
	{ yyval.stnode=MkNode(astDeclListSeq,NULL,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL,NULL);}
break;
case 40:
#line 550 "nectar_syntax"
	{ yyval.stnode=MkNode(astDeclListEmpty,NULL,NULL,NULL,NULL,NULL);}
break;
case 41:
#line 555 "nectar_syntax"
	{

		p1 = pop_vs();
		p2 = new_symbol(yystack.l_mark[-2].ystr);
	    copy_attributes(p2, p1);

		/*Create a pseudonym for this variable, which is important for code generation*/
		strcpy(NUM_VAR_ARR, "ebp - ");
    NUM_BYTES_VAR-=1;
    p2->index = NUM_BYTES_VAR;
		switch(p1->typos){
			case INT:

				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR );

			break;
			case REAL:

				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR);
			break;
			case BOOL:
				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR );

			break;
		}

		strcpy(p2->pseudonym, strcat(NUM_VAR_ARR, TEMP_NUM_VAR_ARR));


		p2->sclass = MEMORY;
		add_symbols_to_table(p2,0);

		push_vs(p1);


  }
break;
case 42:
#line 590 "nectar_syntax"
	{

		pop_vs();
		yyval.stnode=MkNode(astDecl,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);

        }
break;
case 43:
#line 597 "nectar_syntax"
	{

		p1 = pop_vs();
		p2 = new_symbol(yystack.l_mark[-5].ystr);
	    copy_attributes(p2, p1);

		add_array_dcl(p2,atoi(yystack.l_mark[-1].ystr));

		/*Create a pseudonym for this variable, which is important for code generation*/
		strcpy(NUM_VAR_ARR, "ebp - ");

		switch(p1->typos){
			case INT:
			    NUM_BYTES_VAR+=4*(atoi(yystack.l_mark[-1].ystr));
				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR );

			break;
			case REAL:
				NUM_BYTES_VAR+=8*(atoi(yystack.l_mark[-1].ystr));
				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR);

			break;
			case BOOL:
			    NUM_BYTES_VAR+=4*(atoi(yystack.l_mark[-1].ystr));
				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR );

			break;
		}

		strcpy(p2->pseudonym, strcat(NUM_VAR_ARR, TEMP_NUM_VAR_ARR));


		p2->sclass = MEMORY;
		add_symbols_to_table(p2,0);

		push_vs(p1);


		}
break;
case 44:
#line 635 "nectar_syntax"
	{

		pop_vs();
		yyval.stnode=MkNode(astDecl,NULL,yystack.l_mark[-5].stnode,yystack.l_mark[0].stnode,NULL,NULL);

        }
break;
case 45:
#line 641 "nectar_syntax"
	{

		   p3 = pop_vs();
	     p1 = pop_vs();
	     p2 = new_symbol(yystack.l_mark[-4].ystr);
	     copy_attributes(p2, p1);


		 strcpy(NUM_VAR_ARR, "ebp - ");
     NUM_BYTES_VAR -=1;
     p2->index = NUM_BYTES_VAR;
		switch(p1->typos){
			case INT:
				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR);

			break;
			case REAL:
				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR);

			break;
			case BOOL:
				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR);

			break;
		}
		 strcpy(p2->pseudonym, strcat(NUM_VAR_ARR, TEMP_NUM_VAR_ARR));


		 if(!isSuperType(p1->typos, p3->typos)) {
			 printf("Warning: The type of '%s' is not '%d'\n",p1->name,p3->typos);


		 }

	     copy_value(p2,p3);
		 p2->sclass = MEMORY;
	     add_symbols_to_table(p2,0);

		 push_vs(p1);

	     }
break;
case 46:
#line 681 "nectar_syntax"
	{

	     pop_vs();
	     yyval.stnode=MkNode(astDeclAssign,NULL,yystack.l_mark[-4].stnode,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL);
	     }
break;
case 47:
#line 690 "nectar_syntax"
	{
		 p1 = pop_vs();
		 p2 = new_symbol(yystack.l_mark[0].ystr);
	     copy_attributes(p2, p1);


		 strcpy(NUM_VAR_ARR, "ebp - ");
     NUM_BYTES_VAR-=1;
     p2->index = NUM_BYTES_VAR;
		 switch(p1->typos){
			case INT:
				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR );

			break;
			case REAL:
				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR);

			break;
			case BOOL:
				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR );

			break;
		}

		 strcpy(p2->pseudonym, strcat(NUM_VAR_ARR, TEMP_NUM_VAR_ARR));


		 add_symbols_to_table(p2,0);

		 p2->sclass = MEMORY;
		 push_vs(p1);

	     }
break;
case 48:
#line 722 "nectar_syntax"
	{

		p = pop_vs();
		yyval.stnode=MkNode(astVarsSeq,p,yystack.l_mark[0].stnode,NULL,NULL,NULL);
		push_vs(p);

        }
break;
case 49:
#line 729 "nectar_syntax"
	{

		   p3 = pop_vs();
	     p1 = pop_vs();
	     p2 = new_symbol(yystack.l_mark[-2].ystr);
	     copy_attributes(p2, p1);


		strcpy(NUM_VAR_ARR, "ebp - ");
    NUM_BYTES_VAR-=1;
    p2->index = NUM_BYTES_VAR;
		switch(p1->typos){
			case INT:

				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR );

			break;
			case REAL:
				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR);

			break;
			case BOOL:
				sprintf(TEMP_NUM_VAR_ARR, "%d", NUM_BYTES_VAR );

			break;
		}
		 strcpy(p2->pseudonym, strcat(NUM_VAR_ARR, TEMP_NUM_VAR_ARR));


		 if(!isSuperType(p1->typos, p3->typos)) {
			 printf("Warning: The type of '%s' is not '%d'\n",p1->name,p3->typos);


		 }

	     copy_value(p2,p3);
	     add_symbols_to_table(p2,0);

		 p2->sclass = MEMORY;
	     push_vs(p1);


	  }
break;
case 50:
#line 771 "nectar_syntax"
	{

         p=pop_vs();
	     yyval.stnode=MkNode(astVarAssign,p,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);
	     push_vs(p);
      }
break;
case 51:
#line 777 "nectar_syntax"
	{ yyval.stnode=MkNode(astVarEmpty,NULL,NULL,NULL,NULL,NULL); }
break;
case 52:
#line 782 "nectar_syntax"
	{ yyval.stnode=MkNode(astStmtSeq,NULL,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL,NULL); pop_vs();  }
break;
case 53:
#line 783 "nectar_syntax"
	{ yyval.stnode=MkNode(astStmtEmpty,NULL,NULL,NULL,NULL,NULL);}
break;
case 54:
#line 787 "nectar_syntax"
	{
			yyval.stnode=yystack.l_mark[0].stnode;
			pop_vs();
			push_vs(NULL);
	    }
break;
case 55:
#line 792 "nectar_syntax"
	{

			yyval.stnode=yystack.l_mark[0].stnode;
			push_vs(NULL);
        }
break;
case 56:
#line 797 "nectar_syntax"
	{
			yyval.stnode=yystack.l_mark[0].stnode;
			push_vs(NULL);
        }
break;
case 57:
#line 801 "nectar_syntax"
	{
			yyval.stnode=yystack.l_mark[0].stnode;
			push_vs(NULL);
        }
break;
case 58:
#line 805 "nectar_syntax"
	{

		  yyval.stnode=MkNode(astPrintStmt,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);
		  pop_vs();
		  push_vs(NULL);

	    }
break;
case 59:
#line 812 "nectar_syntax"
	{

		  yyval.stnode=MkNode(astPrintLnStmt,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);
		  pop_vs();
		  push_vs(NULL);

	    }
break;
case 60:
#line 819 "nectar_syntax"
	{

		  p2 = new_symbol(yystack.l_mark[0].ystr);
		  p2->typos = LITERAL;

		  yyval.stnode=MkNode(astPrintLtStmt,p2,NULL,NULL,NULL,NULL);

		  push_vs(NULL);

	    }
break;
case 61:
#line 829 "nectar_syntax"
	{

		  p2 = new_symbol(yystack.l_mark[0].ystr);
		  p2->typos = LITERAL;

		  yyval.stnode=MkNode(astPrintLnLtStmt,p2,NULL,NULL,NULL,NULL);

		  push_vs(NULL);

	    }
break;
case 62:
#line 839 "nectar_syntax"
	{

		  p2 = new_symbol(yystack.l_mark[-2].ystr);
		  p2->typos = LITERAL;

		  yyval.stnode=MkNode(astReadStmt,p2,yystack.l_mark[0].stnode,NULL,NULL,NULL);
		  pop_vs();
		  push_vs(NULL);

	    }
break;
case 63:
#line 849 "nectar_syntax"
	{

			pop_vs();
			yyval.stnode=MkNode(astExprStmt,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);
			push_vs(NULL);
		}
break;
case 64:
#line 855 "nectar_syntax"
	{

		  yyval.stnode=MkNode(astPutsStmt,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);

		  push_vs(NULL);

	  }
break;
case 65:
#line 864 "nectar_syntax"
	{ if(enableReturn==1)
		         push_rt(new_symbol("if"));
			 }
break;
case 66:
#line 870 "nectar_syntax"
	{
			yyval.stnode=yystack.l_mark[0].stnode;
			pop_vs();
			push_vs(NULL);
      }
break;
case 67:
#line 875 "nectar_syntax"
	{
			yyval.stnode=yystack.l_mark[0].stnode;
			push_vs(NULL);
      }
break;
case 68:
#line 879 "nectar_syntax"
	{
			yyval.stnode=yystack.l_mark[0].stnode;
			push_vs(NULL);
      }
break;
case 69:
#line 883 "nectar_syntax"
	{
			yyval.stnode=yystack.l_mark[0].stnode;
			push_vs(NULL);
      }
break;
case 70:
#line 887 "nectar_syntax"
	{

      if(enableReturn == 1){

				if(strcmp(returns[TopOfRt]->name,"method") == 0){
					enableReturn =0;
					push_rt(new_symbol("return"));

				}else{

					if(strcmp(returns[TopOfRt]->name,"word") ==0 || strcmp(returns[TopOfRt]->name,"return") ==0 )
					 {
						 pop_rt();
						 push_rt(new_symbol("return"));
					 }else{
				        push_rt(new_symbol("return"));
					 }
				  }
			}
			yyval.stnode=MkNode(astReturnStmt,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);
			p = pop_vs();


			if( !isSuperType(vs[0]->typos, p->typos)){
				printf("Error: The returned type of method '%s' is not '%d'\n", vs[0]->name,p->typos);
				exit(1);
			}
      push_vs(NULL);

      }
break;
case 71:
#line 917 "nectar_syntax"
	{


			p6 = pop_vs();
			p4 = pop_vs();

			/*check_ifelse(p4,p6,p9);*/

			if(enableReturn == 1){

				if (strcmp(returns[TopOfRt]->name, "return") ==0 || strcmp(returns[TopOfRt]->name, "word") ==0){
								pop_rt();
					}

			   pop_rt();

			}

			yyval.stnode=MkNode(astIfStmt,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);

			push_vs(NULL);



	  }
break;
case 72:
#line 942 "nectar_syntax"
	{
				 if (enableReturn == 1){

							if (strcmp(returns[TopOfRt]->name, "return") !=0 && strcmp(returns[TopOfRt]->name, "word") !=0){
								push_rt(new_symbol("word"));
							}

								push_rt(new_symbol("else"));
					}
			   }
break;
case 73:
#line 951 "nectar_syntax"
	{

			p9 = pop_vs();
			p6 = pop_vs();
			p4 = pop_vs();

			/*check_ifelse(p4,p6,p9);*/

			if(enableReturn == 1){

				if (strcmp(returns[TopOfRt]->name, "return") !=0 && strcmp(returns[TopOfRt]->name, "word") !=0){
								push_rt(new_symbol("word"));
					}

				p7 = pop_rt();
				p5 = pop_rt();
				p3 = pop_rt();
				p2 = pop_rt();

				if(strcmp(p3->name,"return") ==0  && strcmp(p7->name,"return") == 0)
					push_rt(new_symbol("return"));
				else if(strcmp(returns[TopOfRt]->name, "word") !=0)
					  push_rt(new_symbol("word"));



			}

			yyval.stnode=MkNode(astIfElseStmt,NULL,yystack.l_mark[-5].stnode,yystack.l_mark[-3].stnode,yystack.l_mark[0].stnode,NULL);

			push_vs(NULL);

      }
break;
case 74:
#line 984 "nectar_syntax"
	{

		  p3 = pop_vs();
		  p1 = pop_vs();

		  yyval.stnode = MkNode(astSingleIfStmt,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);

		  push_vs(NULL);

	  }
break;
case 75:
#line 994 "nectar_syntax"
	{

		  p3 = pop_vs();
		  p1 = pop_vs();

		  yyval.stnode = MkNode(astSingleUnlessStmt,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);

		  push_vs(NULL);

	  }
break;
case 76:
#line 1004 "nectar_syntax"
	{ p = new_symbol("");
				push_wh(p);
				enableReturn =0;
				}
break;
case 77:
#line 1007 "nectar_syntax"
	{

			yyval.stnode=MkNode(astWhileStmt,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);
			p6=pop_vs();
			p4=pop_vs();
			/*check_while(p4,p6);*/
			pop_wh();
		    if(TopOfWhile <0) enableReturn=1;
			push_vs(NULL);

     }
break;
case 78:
#line 1018 "nectar_syntax"
	{ p = new_symbol("");
				push_wh(p);
				enableReturn =0;
				}
break;
case 79:
#line 1021 "nectar_syntax"
	{


			p5=pop_vs();
			p1=pop_vs();
			/*check_while(p4,p6);*/

			if( p1->typos != INT) {

				printf("Error: The number of loop in 'times' statement must be integer\n");
				exit(1);
			}

			yyval.stnode=MkNode(astTimesStmt,NULL,yystack.l_mark[-3].stnode,yystack.l_mark[0].stnode,NULL,NULL);
			pop_wh();
		    if(TopOfWhile <0) enableReturn=1;
			push_vs(NULL);
		}
break;
case 80:
#line 1039 "nectar_syntax"
	{
			 p = pop_wh();
			 if(!p) {
				 printf("Error: break statement not within loop ");
				 exit(1);

			 }else{

				 push_wh(p);
			 }

			 yyval.stnode=MkNode(astBreakStmt,NULL,NULL,NULL,NULL,NULL);
			 push_vs(NULL);
        }
break;
case 81:
#line 1053 "nectar_syntax"
	{
			yyval.stnode=yystack.l_mark[0].stnode;
			push_vs(NULL);
        }
break;
case 82:
#line 1057 "nectar_syntax"
	{

		  yyval.stnode=MkNode(astPrintStmt,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);
		  pop_vs();
		  push_vs(NULL);

	  }
break;
case 83:
#line 1064 "nectar_syntax"
	{

		  yyval.stnode=MkNode(astPrintLnStmt,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);
		  pop_vs();
		  push_vs(NULL);

	  }
break;
case 84:
#line 1071 "nectar_syntax"
	{

		  p2 = new_symbol(yystack.l_mark[0].ystr);
		  p2->typos = LITERAL;

		  yyval.stnode=MkNode(astPrintLtStmt,p2,NULL,NULL,NULL,NULL);

		  push_vs(NULL);

	  }
break;
case 85:
#line 1081 "nectar_syntax"
	{

		  p2 = new_symbol(yystack.l_mark[0].ystr);
		  p2->typos = LITERAL;

		  yyval.stnode=MkNode(astPrintLnLtStmt,p2,NULL,NULL,NULL,NULL);

		  push_vs(NULL);

	  }
break;
case 86:
#line 1091 "nectar_syntax"
	{

		  yyval.stnode=MkNode(astPutsStmt,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);

		  push_vs(NULL);

	  }
break;
case 87:
#line 1098 "nectar_syntax"
	{

		  p2 = new_symbol(yystack.l_mark[-2].ystr);
		  p2->typos = LITERAL;

		  yyval.stnode=MkNode(astReadStmt,p2,yystack.l_mark[0].stnode,NULL,NULL,NULL);
		  pop_vs();
		  push_vs(NULL);

	  }
break;
case 88:
#line 1108 "nectar_syntax"
	{

			pop_vs();
			yyval.stnode=MkNode(astExprStmt,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);
			push_vs(NULL);
		}
break;
case 89:
#line 1124 "nectar_syntax"
	{

		  p1 = pop_vs();

		  yyval.stnode=MkNode(astExprInline,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);


	  }
break;
case 90:
#line 1132 "nectar_syntax"
	{

		  p2 = new_symbol(yystack.l_mark[-2].ystr);
		  p2->typos = LITERAL;

		  yyval.stnode=MkNode(astLiteralInline,p2,yystack.l_mark[0].stnode,NULL,NULL,NULL);

	  }
break;
case 91:
#line 1140 "nectar_syntax"
	{

		  p1 = pop_vs();

		  yyval.stnode=MkNode(astSingleExprInline,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);


	  }
break;
case 92:
#line 1148 "nectar_syntax"
	{

		  p2 = new_symbol(yystack.l_mark[0].ystr);
		  p2->typos = LITERAL;

		  yyval.stnode=MkNode(astSingleLiteralInline,p2,NULL,NULL,NULL,NULL);

	  }
break;
case 93:
#line 1158 "nectar_syntax"
	{ yyval.stnode=yystack.l_mark[-1].stnode;}
break;
case 94:
#line 1163 "nectar_syntax"
	{

		   yyval.stnode=MkNode(astAddAssign,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);
		   p3 = pop_vs();
		   p1 = pop_vs();
		   check_assignment(p1,p3);

		   if(!isSuperType(p1->typos, p3->typos)) {
			 printf("Warning: The type of '%s' is not '%d'\n",p1->name,p3->typos);


		     }

		   /*push_vs(p3);*/
	  }
break;
case 95:
#line 1180 "nectar_syntax"
	{

		   yyval.stnode=MkNode(astSubAssign,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);
		   p3 = pop_vs();
		   p1 = pop_vs();
		   check_assignment(p1,p3);

		   if(!isSuperType(p1->typos, p3->typos)) {
			 printf("Warning: The type of '%s' is not '%d'\n",p1->name,p3->typos);


		    }
		   /*push_vs(p3);*/
	  }
break;
case 96:
#line 1198 "nectar_syntax"
	{

		 yyval.stnode=MkNode(astAssign,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);
	     p3 = pop_vs();
	     p1 = pop_vs();

		 check_assignment(p1,p3);


		  if(!isSuperType(p1->typos, p3->typos)) {
			 printf("Warning: The type of '%s' is not '%d'\n",p1->name,p3->typos);


		 }


		 push_vs(p3);

        }
break;
case 97:
#line 1218 "nectar_syntax"
	{

		 yyval.stnode=MkNode(astAssignSeq,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);
	     p3 = pop_vs();
	     p1 = pop_vs();
		 check_assignment(p1,p3);

		 if(!isSuperType(p1->typos, p3->typos)) {
			 printf("Warning: The type of '%s' is not '%d'\n",p1->name,p3->typos);


		 }


		 push_vs(p3);

	   }
break;
case 98:
#line 1239 "nectar_syntax"
	{


	     p3 = pop_vs();
	     p1 = pop_vs();
		 check_assignment(p1,p3);
		 yyval.stnode=MkNode(astListedAssign,NULL,yystack.l_mark[-4].stnode,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL);

		}
break;
case 99:
#line 1250 "nectar_syntax"
	{

	     p3 = pop_vs();
	     p1 = pop_vs();
		 check_assignment(p1,p3);

		 yyval.stnode=MkNode(astNestedAssign,NULL,yystack.l_mark[-4].stnode,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL);

        }
break;
case 100:
#line 1259 "nectar_syntax"
	{

		 p3 = pop_vs();
	     p1 = pop_vs();
		 check_assignment(p1,p3);

		 yyval.stnode=MkNode(astEmbedAssign,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);

		 }
break;
case 101:
#line 1272 "nectar_syntax"
	{


    			/*strcat(METHOD_NAME,$1);*/
    			p1 = new_symbol(yystack.l_mark[0].ystr);

    			/*
    			if(strcmp(p1->name,"main") == 0) {
    				printf("ERROR: You can't call the main method");
    				exit(1);
    			}*/


    			push_vs(p1);
    			yyval.stnode=MkNode(astMethodName,p1,NULL,NULL,NULL,NULL);

             }
break;
case 102:
#line 1292 "nectar_syntax"
	{
			p1 = findsymb(yystack.l_mark[0].ystr,0);

			if(p1!=NULL){
				/*copy_symbol(p2,p1);*/
				push_vs(p1);
			}
			else{

				printf("Error: '%s' undeclared variable",yystack.l_mark[0].ystr);
				exit(1);
			 }
			/*copy_symbol(p2,p1);*/
			yyval.stnode=MkNode(astLocation,p1,NULL,NULL,NULL,NULL);
}
break;
case 103:
#line 1313 "nectar_syntax"
	{

			p3 = pop_vs();
			p1 = pop_vs();

			p = new_symbol("");

			if (p1->sclass == CONSTANT && p3->sclass == CONSTANT)
				p->sclass = CONSTANT;

			switch(p1->typos){

				 case INT:
						switch(p3->typos){
							case REAL:
								 printf("Error: bad operand types for binary operator \n");
								 exit(1);
							break;
							case INT:
								 printf("Error: bad operand types for binary operator \n");
								 exit(1);
							break;

						}

				 break;
				 case REAL:

						switch(p3->typos){
							case REAL:

								 printf("Error: bad operand types for binary operator \n");
								 exit(1);

							break;
							case INT:

								 printf("Error: bad operand types for binary operator \n");
								 exit(1);

							break;

						}
				 break;
				 case BOOL:

						 switch(p3->typos){

								case REAL:

									printf("Error: bad operand types for binary operator \n");
									exit(1);

								break;
								case INT:

									printf("Error: bad operand types for binary operator \n");
									exit(1);

								break;
								case BOOL:
									 p->typos = BOOL;
								break;

						  }

				 break;



			 }

			yyval.stnode=MkNode(astOrExpr,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);
			/*p = check_logic_op(p1,p3);*/
			push_vs(p);

		}
break;
case 104:
#line 1390 "nectar_syntax"
	{ yyval.stnode= yystack.l_mark[0].stnode;}
break;
case 105:
#line 1395 "nectar_syntax"
	{

			p3 = pop_vs();
			p1 = pop_vs();

			p = new_symbol("");

			if (p1->sclass == CONSTANT && p3->sclass == CONSTANT)
				p->sclass = CONSTANT;

			switch(p1->typos){

				 case INT:
						switch(p3->typos){
							case REAL:
								 printf("Error: bad operand types for binary operator \n");
								 exit(1);
							break;
							case INT:
								 printf("Error: bad operand types for binary operator \n");
								 exit(1);
							break;

						}

				 break;
				 case REAL:

						switch(p3->typos){
							case REAL:

								 printf("Error: bad operand types for binary operator \n");
								 exit(1);

							break;
							case INT:

								 printf("Error: bad operand types for binary operator \n");
								 exit(1);

							break;

						}
				 break;
				 case BOOL:

						 switch(p3->typos){
								case REAL:

									printf("Error: bad operand types for binary operator \n");
									exit(1);

								break;
								case INT:

									printf("Error: bad operand types for binary operator \n");
									exit(1);

								break;
								case BOOL:
									 p->typos = BOOL;
								break;

						  }

				 break;



			 }

			yyval.stnode=MkNode(astAndExpr,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[0].stnode,NULL,NULL);
			/*p = check_logic_op(p1,p3);*/
			push_vs(p);

		}
break;
case 106:
#line 1471 "nectar_syntax"
	{ yyval.stnode = yystack.l_mark[0].stnode;}
break;
case 107:
#line 1475 "nectar_syntax"
	{

			p2 = pop_vs();

			if( p2->typos != BOOL){

				 printf("Error: bad operand types for binary operator \n");
				 exit(1);

			}

			yyval.stnode=MkNode(astNotExpr,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);

			push_vs(p2);


	  }
break;
case 108:
#line 1492 "nectar_syntax"
	{ yyval.stnode=yystack.l_mark[0].stnode;}
break;
case 109:
#line 1496 "nectar_syntax"
	{

		p3 = pop_vs();
		p1 = pop_vs();

		p = new_symbol("");

		if (p1->sclass == CONSTANT && p3->sclass == CONSTANT)
				p->sclass = CONSTANT;

		switch(p1->typos){

			 case INT:
					switch(p3->typos){
						case REAL:
							p->typos = INT;
						break;
						case INT:
							p->typos = INT;
						break;
						case BOOL:
						    printf("Error: bad operand types for binary operator \n");
							exit(1);
						break;

					}

			 break;
			 case REAL:

					switch(p3->typos){
						case REAL:
							p->typos = INT;
						break;
						case INT:
							p->typos = INT;
						break;
						case BOOL:
						    printf("Error: bad operand types for binary operator \n");
							exit(1);
						break;

					}
			 break;
			 case BOOL:

					if( yystack.l_mark[-1].stnode->NodeType == astEOp || yystack.l_mark[-1].stnode->NodeType == astNeOp){

							switch(p3->typos){
								case REAL:
									printf("Error: bad operand types for binary operator \n");
								break;
								case INT:
									printf("Error: bad operand types for binary operator \n");
								break;
								case BOOL:
									p->typos = BOOL;
								break;

							}
					}
					else {
						printf("Error: bad operand types for binary operator \n");
						exit(1);
					}

			 break;


		 }

		yyval.stnode=MkNode(astCompExpr,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL);
		/*p = check_logic_op(p1,p3);*/
	    push_vs(p);
}
break;
case 110:
#line 1571 "nectar_syntax"
	{ yyval.stnode=yystack.l_mark[0].stnode;}
break;
case 111:
#line 1575 "nectar_syntax"
	{ yyval.stnode=MkNode(astGeOp,NULL,NULL,NULL,NULL,NULL);}
break;
case 112:
#line 1576 "nectar_syntax"
	{ yyval.stnode=MkNode(astGOp,NULL,NULL,NULL,NULL,NULL);}
break;
case 113:
#line 1577 "nectar_syntax"
	{ yyval.stnode=MkNode(astLeOp,NULL,NULL,NULL,NULL,NULL);}
break;
case 114:
#line 1578 "nectar_syntax"
	{ yyval.stnode=MkNode(astLOp,NULL,NULL,NULL,NULL,NULL);}
break;
case 115:
#line 1579 "nectar_syntax"
	{ yyval.stnode=MkNode(astNeOp,NULL,NULL,NULL,NULL,NULL);}
break;
case 116:
#line 1580 "nectar_syntax"
	{ yyval.stnode=MkNode(astEOp,NULL,NULL,NULL,NULL,NULL);}
break;
case 117:
#line 1585 "nectar_syntax"
	{


	     p3 = pop_vs();
		 p1 = pop_vs();

		 p = new_symbol("");

		 if (p1->sclass == CONSTANT && p3->sclass == CONSTANT)
				p->sclass = CONSTANT;

		switch(p1->typos){

			 case INT:
					switch(p3->typos){
						case REAL:
							p->typos = REAL;
						break;
						case INT:
							p->typos = INT;
						break;
						case BOOL:
						    printf("Error: bad operand types for binary operator \n");
							exit(1);
						break;

					}

			 break;
			 case REAL:

					switch(p3->typos){
						case REAL:
							p->typos = REAL;
						break;
						case INT:
							p->typos = REAL;
						break;
						case BOOL:
						    printf("Error: bad operand types for binary operator \n");
							exit(1);
						break;

					}
			 break;
			 case BOOL:

					printf("Error: bad operand types for binary operator \n");
				    exit(1);

			 break;


		 }

         yyval.stnode=MkNode(astAddExpr,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL);
	     push_vs(p);
        }
break;
case 118:
#line 1643 "nectar_syntax"
	{ yyval.stnode=yystack.l_mark[0].stnode;}
break;
case 119:
#line 1647 "nectar_syntax"
	{ yyval.stnode=MkNode(astAddOp,NULL,NULL,NULL,NULL,NULL);}
break;
case 120:
#line 1648 "nectar_syntax"
	{ yyval.stnode=MkNode(astSubOp,NULL,NULL,NULL,NULL,NULL);}
break;
case 121:
#line 1652 "nectar_syntax"
	{


	     p3 = pop_vs();
	     p1 = pop_vs();

		 p = new_symbol("");

		 /*p = check_muldiv_arithm_op(p1,p3);*/

		 if (p1->sclass == CONSTANT && p3->sclass == CONSTANT)
				p->sclass = CONSTANT;

		 switch(p1->typos){

			 case INT:
					switch(p3->typos){
						case REAL:
							p->typos = REAL;
						break;
						case INT:
							p->typos = INT;
						break;
						case BOOL:
						    printf("Error: bad operand types for binary operator \n");
							exit(1);
						break;

					}

			 break;
			 case REAL:

					switch(p3->typos){
						case REAL:
							p->typos = REAL;
						break;
						case INT:
							p->typos = REAL;
						break;
						case BOOL:
						    printf("Error: bad operand types for binary operator \n");
							exit(1);
						break;

					}
			 break;
			 case BOOL:

					printf("Error: bad operand types for binary operator \n");
				    exit(1);

			 break;


		 }


	     yyval.stnode=MkNode(astMulExpr,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL);
         p->lvalue = 0;
	     push_vs(p);
}
break;
case 122:
#line 1714 "nectar_syntax"
	{ yyval.stnode=yystack.l_mark[0].stnode;}
break;
case 123:
#line 1718 "nectar_syntax"
	{  yyval.stnode=MkNode(astMulOp,NULL,NULL,NULL,NULL,NULL);}
break;
case 124:
#line 1719 "nectar_syntax"
	{  yyval.stnode=MkNode(astDivOp,NULL,NULL,NULL,NULL,NULL);}
break;
case 125:
#line 1720 "nectar_syntax"
	{  yyval.stnode=MkNode(astModOp,NULL,NULL,NULL,NULL,NULL);}
break;
case 126:
#line 1724 "nectar_syntax"
	{ yyval.stnode= yystack.l_mark[0].stnode; }
break;
case 127:
#line 1725 "nectar_syntax"
	{ yyval.stnode=yystack.l_mark[-1].stnode;}
break;
case 128:
#line 1726 "nectar_syntax"
	{ yyval.stnode=yystack.l_mark[0].stnode;}
break;
case 129:
#line 1727 "nectar_syntax"
	{
          p1=new_symbol("");
          p1->typos=INT;
          p1->sclass=CONSTANT;
          p1->lvalue=0;
          p1->timi=atoi(yystack.l_mark[0].ystr);
          p1->has_timi=CONST_VAL;
          push_vs(p1);
	      yyval.stnode = MkNode(astDeConst,p1,NULL,NULL,NULL,NULL);
         }
break;
case 130:
#line 1738 "nectar_syntax"
	{
          p1=new_symbol("");
          p1->typos=REAL;
          p1->sclass=CONSTANT;
          p1->lvalue=0;
          p1->dtimi=atof(yystack.l_mark[0].ystr);
          p1->has_timi=CONST_VAL;
          push_vs(p1);
	      yyval.stnode = MkNode(astRealDeConst,p1,NULL,NULL,NULL,NULL);
         }
break;
case 131:
#line 1748 "nectar_syntax"
	{
	      p1 = new_symbol("");
          p1->sclass=CONSTANT;
		  p1->typos = BOOL;
          p1->lvalue=0;
          p1->timi=1;
          p1->has_timi=CONST_VAL;
	      push_vs(p1);
	      yyval.stnode = MkNode(astTrue,p1,NULL,NULL,NULL,NULL);
       }
break;
case 132:
#line 1758 "nectar_syntax"
	{
	      p1 = new_symbol("");
          p1->sclass=CONSTANT;
		  p1->typos = BOOL;
          p1->lvalue=0;
          p1->timi=0;
          p1->has_timi=CONST_VAL;
	      push_vs(p1);
          yyval.stnode = MkNode(astFalse,p1,NULL,NULL,NULL,NULL);
       }
break;
case 133:
#line 1768 "nectar_syntax"
	{

		  p2 = pop_vs();
		  p1 = pop_vs();

		  strcpy(METHOD_NAME_TEMP,"");

	      while(strcmp(p1->name,"259") == 0 || strcmp(p1->name,"274") == 0 || strcmp(p1->name,"276") == 0 ){

			  strcat(METHOD_NAME_TEMP,p1->name);
			  p1 = pop_vs();
		  }


		  strcpy(METHOD_NAME,p1->name);
		  strcat(METHOD_NAME,METHOD_NAME_TEMP);
		  p3 = new_symbol(METHOD_NAME);

		  strcpy(METHOD_NAME,"");
		  strcpy(METHOD_NAME_TEMP,"");

		  p = findsymb(p3->name,1);

		  if(p == NULL){
             printf("Error: '%s' undeclared method",p3->name);
			 exit(1);
		    }
		  /*printf("%s\n",p->name);*/
		 /* printf("%d\n",numOfArguments);*/

		 /* if(p->dcl_ptr->num_params != numOfArguments){

			  printf("Error: The number of arguments must match");
			  exit(1);
		  }
		  */

          yyval.stnode = MkNode(astMethodCall,p,yystack.l_mark[-3].stnode,yystack.l_mark[-1].stnode,NULL,NULL);
 	      push_vs(p);

		  /*numOfArguments =0;*/
	}
break;
case 134:
#line 1811 "nectar_syntax"
	{
          p1=new_symbol("");
          p1->typos=INT;
          p1->sclass=CONSTANT;
          p1->lvalue=0;
          p1->timi=-atoi(yystack.l_mark[0].ystr);
          p1->has_timi=CONST_VAL;
          push_vs(p1);
	      yyval.stnode = MkNode(astDeConst,p1,NULL,NULL,NULL,NULL);
        }
break;
case 135:
#line 1821 "nectar_syntax"
	{
          p1=new_symbol("");
          p1->typos=REAL;
          p1->sclass=CONSTANT;
          p1->lvalue=0;
          p1->dtimi= -atof(yystack.l_mark[-1].ystr);
          p1->has_timi=CONST_VAL;
          push_vs(p1);
	      yyval.stnode = MkNode(astRealDeConst,p1,NULL,NULL,NULL,NULL);
         }
break;
case 136:
#line 1834 "nectar_syntax"
	{

		  p1 = pop_vs();

		 if(p1->typos != INT) {

			  printf("Error: Only integers you can increase by one\n");
			  exit(1);
		  }

		 push_vs(p1);

		 /*here you should check if location is integer*/
		 yyval.stnode = MkNode(astIncreaseAfter,NULL,yystack.l_mark[-1].stnode,NULL,NULL,NULL);

	 }
break;
case 137:
#line 1850 "nectar_syntax"
	{

		 p2 = pop_vs();

		 if(p2->typos != INT) {

			  printf("Error: Only integers you can increase by one\n");
			  exit(1);
		  }

		 push_vs(p2);

		 /*here you should check if location is integer*/
		 yyval.stnode = MkNode(astIncreaseBefore,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);

	 }
break;
case 138:
#line 1866 "nectar_syntax"
	{

		 p1 = pop_vs();

		 if(p1->typos != INT) {

			  printf("Error: Only integers you can decrease by one\n");
			  exit(1);
		  }

		 push_vs(p1);

		  /*here you should check if location is integer*/
		 yyval.stnode = MkNode(astDecreaseAfter,NULL,yystack.l_mark[-1].stnode,NULL,NULL,NULL);

	 }
break;
case 139:
#line 1882 "nectar_syntax"
	{

		  p2 = pop_vs();

		  if(p2->typos != INT) {

			  printf("Error: Only integers you can decrease by one\n");
			  exit(1);
		  }

		  push_vs(p2);

		  /*here you should check if location is integer*/
		 yyval.stnode = MkNode(astDecreaseBefore,NULL,yystack.l_mark[0].stnode,NULL,NULL,NULL);

	 }
break;
case 140:
#line 1901 "nectar_syntax"
	{
	  p2 = pop_vs();

	  /*numOfArguments++;*/

	 sprintf(METHOD_NAME_PARS,"%d",p2->typos);
	 p1 = new_symbol(METHOD_NAME_PARS);
	 p1->typos = p2->typos;

	 push_vs(p1);

	 push_vs(NULL);

	  yyval.stnode=MkNode(astActuals,NULL,yystack.l_mark[-1].stnode,yystack.l_mark[0].stnode,NULL,NULL);}
break;
case 141:
#line 1915 "nectar_syntax"
	{ yyval.stnode=MkNode(astActualsEmpty,NULL,NULL,NULL,NULL,NULL); push_vs(NULL);}
break;
case 142:
#line 1919 "nectar_syntax"
	{

		p2 = pop_vs();
		/*numOfArguments++;*/

		sprintf(METHOD_NAME_PARS,"%d",p2->typos);
		 p1 = new_symbol(METHOD_NAME_PARS);
	     p1->typos = p2->typos;

	 push_vs(p1);

		yyval.stnode=MkNode(astArgsSeq,NULL,yystack.l_mark[-2].stnode,yystack.l_mark[-1].stnode,NULL,NULL);}
break;
case 143:
#line 1931 "nectar_syntax"
	{ yyval.stnode=MkNode(astArgsEmpty,NULL,NULL,NULL,NULL,NULL);}
break;
#line 3888 "y.tab.c"
    }
    yystack.s_mark -= yym;
    yystate = *yystack.s_mark;
    yystack.l_mark -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yystack.s_mark = YYFINAL;
        *++yystack.l_mark = yyval;
        if (yychar < 0)
        {
            if ((yychar = YYLEX) < 0) yychar = YYEOF;
#if YYDEBUG
            if (yydebug)
            {
                yys = yyname[YYTRANSLATE(yychar)];
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == YYEOF) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yystack.s_mark, yystate);
#endif
    if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
    {
        goto yyoverflow;
    }
    *++yystack.s_mark = (YYINT) yystate;
    *++yystack.l_mark = yyval;
    goto yyloop;

yyoverflow:
    YYERROR_CALL("yacc stack overflow");

yyabort:
    yyfreestack(&yystack);
    return (1);

yyaccept:
    yyfreestack(&yystack);
    return (0);
}
